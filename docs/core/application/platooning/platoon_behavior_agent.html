<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>opencda.core.application.platooning.platoon_behavior_agent API documentation</title>
<meta name="description" content="Behavior manager for platooning specifically" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>opencda.core.application.platooning.platoon_behavior_agent</code></h1>
</header>
<section id="section-intro">
<p>Behavior manager for platooning specifically</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;Behavior manager for platooning specifically
&#34;&#34;&#34;
# Author: Runsheng Xu &lt;rxx3386@ucla.edu&gt;
# License: MIT

import weakref
from collections import deque

import carla
import numpy as np

from opencda.core.application.platooning.fsm import FSM
from opencda.core.application.platooning.platoon_debug_helper import PlatoonDebugHelper
from opencda.core.common.misc import compute_distance, get_speed, cal_distance_angle
from opencda.core.plan.behavior_agent import BehaviorAgent


class PlatooningBehaviorAgent(BehaviorAgent):
    &#34;&#34;&#34;
    The behavior agent for platooning
    &#34;&#34;&#34;

    def __init__(self, vehicle, vehicle_manager, v2x_manager, behavior_yaml, platoon_yaml, carla_map):
        &#34;&#34;&#34;
        Construct class
        :param vehicle: carla actor todo:remove this later
        :param vehicle_manager: vehicle manager of this agent.
        :param v2x_manager: communication manager
        :param behavior_yaml: configure yaml file for normal behavior agent
        :param platoon_yaml:  configure yaml file for platoon behavior agent
        :param carla_map: Carla HD Map
        :return
        &#34;&#34;&#34;

        super(PlatooningBehaviorAgent, self).__init__(vehicle, carla_map, behavior_yaml)

        self.vehicle_manager = weakref.ref(vehicle_manager)()
        # communication manager
        self.v2x_manager = weakref.ref(v2x_manager)()

        # used for gap keeping
        self.inter_gap = platoon_yaml[&#39;inter_gap&#39;]
        # used when open a gap
        self.open_gap = platoon_yaml[&#39;open_gap&#39;]
        # this is used to control gap opening during cooperative joining
        self.current_gap = self.inter_gap

        # used for merging vehicle
        self.destination_changed = False

        # merging vehicle needs to reach this speed before cooperative merge
        self.warm_up_speed = platoon_yaml[&#39;warm_up_speed&#39;]

        # used to calculate performance
        self.debug_helper = PlatoonDebugHelper(self.vehicle.id)
        self.time_gap = 100.0
        self.dist_gap = 100.0

    def run_step(self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True):
        &#34;&#34;&#34;
        Run a single step for navigation under platooning agent. Finite state machine is used to switch between
        different platooning states.
        Args:
            target_speed (float): Target speed in km/h
            collision_detector_enabled (bool): Whether collision detection enabled.
            lane_change_allowed (bool): Whether lane change is allowed.

        Returns:

        &#34;&#34;&#34;
        # reset time gap and distance gap record at the beginning
        self.time_gap = 100.0
        self.dist_gap = 100.0

        status = self.v2x_manager.get_platoon_status()
        # case1: the vehicle is not cda enabled
        if status == FSM.DISABLE:
            return super().run_step(target_speed, collision_detector_enabled)

        # case2: single vehicle keep searching platoon to join
        if status == FSM.SEARCHING:
            find_platoon, min_index, white_list = self.v2x_manager.match_platoon()
            # we only ignore platoon members for collision detection during joining process
            self.white_list = white_list

            # no platoon found, stay in searching status
            if not find_platoon:
                return super().run_step(target_speed, collision_detector_enabled)

            # platoon found and agreement achieved
            front_vehicle, rear_vehicle = self.v2x_manager.get_platoon_front_rear()
            # if no front vehicle, meaning it will be a frontal joining
            if not front_vehicle and rear_vehicle:
                print(&#39;merging vehicle chooses frontal joining&#39;)
                self.v2x_manager.set_platoon_status(FSM.FRONT_JOINING)
            # if front vehicle and rear vehicle both exist
            if front_vehicle and rear_vehicle:
                print(&#34;merging vehicle chooses cut-in joining&#34;)
                self.v2x_manager.set_platoon_status(FSM.MOVE_TO_POINT)
            # if only front vehicle exits
            if front_vehicle and not rear_vehicle:
                print(&#34;merging vehicle chooses back joining&#34;)
                self.v2x_manager.set_platoon_status(FSM.BACK_JOINING)

            return super().run_step(target_speed, collision_detector_enabled)

        # case3.1: the merging vehicle chooses cut-in joining and is moving to the meeting point
        if status == FSM.MOVE_TO_POINT:
            target_speed, target_waypoint, new_status = self.run_step_cut_in_move2point()
            self.v2x_manager.set_platoon_status(new_status)
            return target_speed, target_waypoint
        # case3.2: the merging vehicle chooses cut-in joining and is ready for merging
        if status == FSM.JOINING:
            target_speed, target_waypoint, new_status = self.run_step_cut_in_joining()
            # if joining is finished
            if new_status == FSM.JOINING_FINISHED:
                self.joining_finish_manager()
            return target_speed, target_waypoint

        # case 4: the merging vehicle selects back joining
        if status == FSM.BACK_JOINING:
            target_speed, target_waypoint, new_status = self.run_step_back_joining()
            # if joining is finshed
            if new_status == FSM.JOINING_FINISHED:
                self.joining_finish_manager()
            return target_speed, target_waypoint

        # case 5: the merging vehicle selects frontal joining
        if status == FSM.FRONT_JOINING:
            target_speed, target_waypoint, new_status = self.run_step_front_joining()
            self.v2x_manager.set_platoon_status(new_status)

            # if joining abandoned
            if new_status == FSM.ABONDON:
                self.v2x_manager.set_platoon_status(FSM.SEARCHING)
                _, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
                self.v2x_manager.add_platoon_blacklist(rear_vehicle_manager.v2x_manager.get_platoon_manager()[0].pmid)
            if new_status == FSM.JOINING_FINISHED:
                self.joining_finish_manager(&#39;rear&#39;)

            return target_speed, target_waypoint

        # case 6: leading vehicle behavior
        if status == FSM.LEADING_MODE:
            return super().run_step(target_speed, collision_detector_enabled)

        # case7: maintaining status
        if status == FSM.MAINTINING:
            return self.run_step_maintaining()

        # case8: Open Gap status
        if status == FSM.OPEN_GAP:
            return self.run_step_open_gap()

    def update_information(self, ego_pos, ego_speed, objects):
        &#34;&#34;&#34;
        Update the perception and localization information to the behavior agent.
        Args:
            ego_pos (carla.Transform): ego position from localization module.
            ego_speed (float): km/h, ego speed.
            objects (dictionary): Objects detection results from perception module.
        &#34;&#34;&#34;
        # update localization information
        self._ego_speed = ego_speed
        self._ego_pos = ego_pos
        self.break_distance = self._ego_speed / 3.6 * self.emergency_param
        # update the localization info to trajectory planner
        self.get_local_planner().update_information(ego_pos, ego_speed)

        # current version only consider about vehicles
        obstacle_vehicles = objects[&#39;vehicles&#39;]
        self.obstacle_vehicles = self.white_list_match(obstacle_vehicles)

        # update the debug helper
        self.debug_helper.update(ego_speed, self.ttc, time_gap=self.time_gap, dist_gap=self.dist_gap)

        if self.ignore_traffic_light:
            self.light_state = &#34;Green&#34;
        else:
            # This method also includes stop signs and intersections.
            self.light_state = str(self.vehicle.get_traffic_light_state())

    def joining_finish_manager(self, insert_vehicle=&#39;front&#39;):
        &#34;&#34;&#34;
        Called when a joining is finish to update the platoon manager list.
        :param insert_vehicle: indicate use the front or rear vehicle index to update the platoon manager list.
        :return:
        &#34;&#34;&#34;
        frontal_vehicle_manager, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
        if insert_vehicle == &#39;front&#39;:
            platoon_manger, index = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
            platoon_manger.set_member(self.vehicle_manager, index + 1)
            self._local_planner.debug_trajectory = False
        else:
            platoon_manger, index = rear_vehicle_manager.v2x_manager.get_platoon_manager()
            platoon_manger.set_member(self.vehicle_manager, index, lead=True)

        platoon_manger.update_member_order()

    def calculate_gap(self, distance):
        &#34;&#34;&#34;
        Calculate the current vehicle and frontal vehicle&#39;s time/distance gap
        :param distance:  distance between the ego vehicle and frontal vehicle
        :return:
        &#34;&#34;&#34;
        # we need to count the vehicle length in to calculate the gap
        boundingbox = self.vehicle.bounding_box
        veh_length = 2 * abs(boundingbox.location.y - boundingbox.extent.y)

        delta_v = self._ego_speed / 3.6
        time_gap = distance / delta_v
        self.time_gap = time_gap
        self.dist_gap = distance - veh_length

    def platooning_following_manager(self, inter_gap):
        &#34;&#34;&#34;
        Car following behavior in platooning with gap regulation
        :param inter_gap: the gap designed for platooning
        :return:
        &#34;&#34;&#34;

        frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
        frontal_front_vehicle_manger, _ = frontal_vehicle_manager.v2x_manager.get_platoon_front_rear()

        if len(self._local_planner.get_trajetory()) &gt; self.get_local_planner().trajectory_update_freq - 2:
            return self._local_planner.run_step([], [], [], following=True)
        else:
            # this agent is a behavior agent 
            frontal_trajectory = frontal_vehicle_manager.agent.get_local_planner().get_trajetory()

            # get front speed
            frontal_speed = frontal_vehicle_manager.agent._ego_speed

            ego_trajetory = deque(maxlen=30)
            ego_loc_x, ego_loc_y, ego_loc_z = self._ego_pos.location.x, self._ego_pos.location.y, \
                                              self._ego_pos.location.z

            # get ego speed
            ego_speed = self._ego_speed

            # compare speed with frontal veh
            frontal_speedd_diff = ego_speed - frontal_speed

            tracked_length = len(frontal_trajectory) - 1 if not frontal_front_vehicle_manger \
                else len(frontal_trajectory)

            # todo: current not working well on curve
            for i in range(tracked_length):
                delta_t = self.get_local_planner().dt
                # if leader is slowing down(leader target speed is smaller than current speed), use a bigger dt.
                # spd diff max at 15. If diff greater than 8, increase dt
                if frontal_speedd_diff &gt; 3.0:
                    &#39;&#39;&#39;
                    # only increase dt when V_ego &gt; V_front (avoid collision)
                    # if V_ego &lt; V_front (diff &lt; 0), stick with small dt 
                    # todo: change delta_t to a function: 
                    #      --&gt; 1. {V_ego &gt; V_front}: decrease dt to increase gap, help avoid collision
                    #      --&gt; 2. more difference, more dt adjustment 
                    #      --&gt; 3. {V_ego &lt; V_front}: will not collide, keep default dt to keep gap
                    #      --&gt; 4. {V_ego ~ V_front}: keep default dt to keep gap 
                    &#39;&#39;&#39;
                    delta_t = delta_t + frontal_speedd_diff * 0.0125

                # print(&#39;previous x :%f, delta t: %f&#39; % (frontal_trajectory[i][0].location.x, delta_t))
                if i == 0:
                    pos_x = (frontal_trajectory[i][0].location.x + inter_gap / delta_t * ego_loc_x) / \
                            (1 + inter_gap / delta_t)
                    pos_y = (frontal_trajectory[i][0].location.y + inter_gap / delta_t * ego_loc_y) / \
                            (1 + inter_gap / delta_t)
                else:
                    pos_x = (frontal_trajectory[i][0].location.x +
                             inter_gap / delta_t * ego_trajetory[i - 1][0].location.x) / \
                            (1 + inter_gap / delta_t)
                    pos_y = (frontal_trajectory[i][0].location.y +
                             inter_gap / delta_t * ego_trajetory[i - 1][0].location.y) / \
                            (1 + inter_gap / delta_t)

                distance = np.sqrt((pos_x - ego_loc_x) ** 2 + (pos_y - ego_loc_y) ** 2)
                velocity = distance / delta_t * 3.6
                ego_trajetory.append([carla.Transform(
                    carla.Location(pos_x, pos_y,
                                   self._map.get_waypoint(self._ego_pos.location).transform.location.z)),
                    velocity])

                ego_loc_x = pos_x
                ego_loc_y = pos_y

            if not ego_trajetory:
                wpt = self._map.get_waypoint(self._ego_pos.location)
                next_wpt = wpt.next(max(2, int(self._ego_speed / 3.6 * 1)))[0]
                ego_trajetory.append((next_wpt.transform,
                                      self._ego_speed))

            return self._local_planner.run_step([], [], [], trajectory=ego_trajetory)

    def platooning_merge_management(self, frontal_vehicle_vm):
        &#34;&#34;&#34;
        Merge the vehicle into the platooning
        :param frontal_vehicle_vm:
        :return:
        &#34;&#34;&#34;
        print(&#34;start merging !&#34;)
        self.lane_change_allowed = True
        frontal_vehicle_loc = frontal_vehicle_vm.vehicle.get_location()

        # we choose next waypoint of the frontal vehicle as starting point to have smooth speed
        frontal_vehicle_waypoint = frontal_vehicle_vm.agent._map.get_waypoint(frontal_vehicle_loc)
        frontal_vehicle_next_waypoint = frontal_vehicle_waypoint.next(
            get_speed(frontal_vehicle_vm.vehicle, True))[0].transform.location

        # retrieve the platooning&#39;s destination
        platooning_manager, _ = frontal_vehicle_vm.v2x_manager.get_platoon_manager()
        destination = platooning_manager.destination

        # regenerate route the route to make merge(lane change)
        self.set_destination(frontal_vehicle_next_waypoint, destination, clean=True)

        target_speed, target_waypoint = super().run_step(target_speed=1.5 * get_speed(frontal_vehicle_vm.vehicle),
                                                         collision_detector_enabled=False)

        return target_speed, target_waypoint

    def run_step_maintaining(self):
        &#34;&#34;&#34;
        Behavior planning for speed maintaining
        :return:
        &#34;&#34;&#34;
        frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
        self.current_gap = self.inter_gap

        frontal_vehicle = frontal_vehicle_manager.vehicle
        frontal_vehicle_loc = frontal_vehicle.get_location()
        ego_vehicle_loc = self._ego_pos.location

        # headway distance
        distance = compute_distance(ego_vehicle_loc, frontal_vehicle_loc)
        self.calculate_gap(distance)

        # Distance is computed from the center of the two cars,
        # use bounding boxes to calculate the actual distance
        distance = distance - max(
            frontal_vehicle.bounding_box.extent.y, frontal_vehicle.bounding_box.extent.x) - max(
            self.vehicle.bounding_box.extent.y, self.vehicle.bounding_box.extent.x)

        # safe control for car following todo: make the coefficient controllable
        if distance &lt;= self._ego_speed / 3.6 * 0.01:
            print(&#34;emergency stop!&#34;)
            return 0, None

        target_speed, target_waypoint = self.platooning_following_manager(self.inter_gap)

        return target_speed, target_waypoint

    def run_step_cut_in_move2point(self):
        &#34;&#34;&#34;
        The vehicle is trying to get to the move in point
        :return: target_speed, target_waypoint, next FSM state
        &#34;&#34;&#34;

        frontal_vehicle_manager, rear_vehicle_vm = self.v2x_manager.get_platoon_front_rear()
        frontal_vehicle = frontal_vehicle_manager.vehicle

        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # calculate the time gap with the frontal vehicle
        self.calculate_gap(distance)

        # if there is a obstacle blocking ahead, we just change to back joining mode todo: lane change not considered
        if self.hazard_flag:
            if rear_vehicle_vm:
                rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.MAINTINING)
            # retrieve the last member in the platoon
            platoon_manager, _ = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
            last_member = platoon_manager.vehicle_manager_list[-1]

            # set the last member as the frontal vehicle
            self.v2x_manager.set_platoon_front(last_member)
            self.v2x_manager.set_platoon_rear(None)
            print(&#39;switch to back joining!&#39;)
            # slow down to join back
            return (*super().run_step(self.max_speed / 2), FSM.BACK_JOINING)

        # the vehicle needs to warm up first. But if the platooning is in car following state, then we should ignore
        if self._ego_speed &lt;= self.warm_up_speed and not frontal_vehicle_manager.agent.car_following_flag:
            print(&#34;warming up speed&#34;)
            return (*super().run_step(self.tailgate_speed), FSM.MOVE_TO_POINT)

        # if the ego vehicle is still too far away from the front vehicle
        if distance &gt; self._ego_speed / 3.6 * (self.inter_gap + 0.5) and angle &lt;= 80:
            print(&#39;trying to get the vehicle&#39;)
            return (*super().run_step(2.0 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

        # if the ego vehicle is too close or exceed the frontal vehicle
        if distance &lt; self._ego_speed / 3.6 * self.inter_gap / 1.5 or angle &gt;= 70:
            print(&#39;too close, step back!&#39;)
            return (*super().run_step(0.9 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

        # communicate to the rear vehicle for open gap if rear vehicle exists
        if not rear_vehicle_vm:
            return (*self.platooning_merge_management(frontal_vehicle_manager), FSM.JOINING)

        distance, angle = cal_distance_angle(rear_vehicle_vm.vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # check whether the rear vehicle gives enough gap
        if distance &lt; 1.0 * self.inter_gap / 2.0 * self._ego_speed / 3.6 \
                or angle &lt;= 100 or rear_vehicle_vm.agent.current_gap &lt; self.open_gap:
            # force the rear vehicle open gap for self
            print(&#34;too close to rear vehicle!&#34;)
            rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.OPEN_GAP)
            return (*super().run_step(1.5 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

        return (*self.platooning_merge_management(frontal_vehicle_manager), FSM.JOINING)

    def run_step_cut_in_joining(self):
        &#34;&#34;&#34;
        Check if the vehicle has been joined successfully TODO: Return status instead of True of False
        :return:
        &#34;&#34;&#34;
        print(&#34;merging speed %d&#34; % self._ego_speed)

        frontal_vehicle_manager, rear_vehicle_vm = self.v2x_manager.get_platoon_front_rear()

        frontal_vehicle = frontal_vehicle_manager.vehicle
        frontal_lane = self._map.get_waypoint(frontal_vehicle.get_location()).lane_id

        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_lane = self._map.get_waypoint(ego_vehicle_loc).lane_id
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)
        # calculate the time gap with the frontal vehicle
        self.calculate_gap(distance)

        if frontal_lane == ego_vehicle_lane and angle &lt;= 5:
            print(&#39;merge finished&#39;)
            if rear_vehicle_vm:
                rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.MAINTINING)
            return (*self.run_step_maintaining(), FSM.JOINING_FINISHED)

        return (*super().run_step(target_speed=get_speed(frontal_vehicle),
                                  collision_detector_enabled=False), FSM.JOINING)

    def run_step_open_gap(self):
        &#34;&#34;&#34;
        Open gap for cut-in vehicle
        :return:
        &#34;&#34;&#34;
        frontal_vehicle_manager, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()

        # calculate the time gap under this state
        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, _ = cal_distance_angle(frontal_vehicle_manager.localizer.get_ego_pos().location,
                                         ego_vehicle_loc, ego_vehicle_yaw)
        self.calculate_gap(distance)

        # gradually open the gap TODO: Make this dynamic to map a linear relationship with speed
        if self.current_gap &lt; self.open_gap:
            self.current_gap += 0.01
        print(&#39;cuurent gap is %f&#39; % self.current_gap)
        target_speed, target_loc = self.platooning_following_manager(self.current_gap)

        return target_speed, target_loc

    def run_step_back_joining(self):
        &#34;&#34;&#34;
        Back-joining Algorithm
        :return: control command and whether back joining finished
        &#34;&#34;&#34;
        frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
        # reset lane change flag every step

        # get necessary information of the ego vehicle and target vehicle in the platooning
        frontal_vehicle = frontal_vehicle_manager.vehicle
        frontal_lane = self._map.get_waypoint(frontal_vehicle.get_location()).lane_id

        # retrieve the platooning&#39;s destination
        platooning_manager, _ = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
        frontal_destination = platooning_manager.destination

        # retrieve ego vehicle info todo: remove this later
        ego_vehicle_loc = self._ego_pos.location
        ego_wpt = self._map.get_waypoint(ego_vehicle_loc)
        ego_vehicle_lane = ego_wpt.lane_id
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # calculate the time gap with the frontal vehicle
        self.calculate_gap(distance)

        # 0. make sure the vehicle is behind the ego vehicle
        if angle &gt;= 60 or distance &lt; self._ego_speed / 3.6 * 0.5:
            self.overtake_allowed = False
            print(&#34;angle is too large, wait&#34;)
            return (*super().run_step(get_speed(frontal_vehicle) * 0.90, lane_change_allowed=False), FSM.BACK_JOINING)

        else:
            self.overtake_allowed = True

        # 1. make sure the speed is warmed up first. Also we don&#39;t want to reset destination during lane change
        if self._ego_speed &lt; self.warm_up_speed or self.get_local_planner().lane_change:
            print(&#39;warm up speed&#39;)
            return (*super().run_step(self.tailgate_speed), FSM.BACK_JOINING)

        if not self.destination_changed:
            print(&#39;destination reset!!!!&#39;)
            self.destination_changed = True
            self.set_destination(ego_wpt.next(4.5)[0].transform.location, frontal_destination,
                                 clean=True, clean_history=True)

        # 2. check if there is any other vehicle blocking between ego and platooning
        def dist(v):
            return v.get_location().distance(ego_vehicle_loc)

        vehicle_blocking_status = False
        for vehicle in self.obstacle_vehicles:
            vehicle_blocking_status = vehicle_blocking_status or self._collision_check.is_in_range(self._ego_pos,
                                                                                                   frontal_vehicle,
                                                                                                   vehicle,
                                                                                                   self._map)

        # 3. if no other vehicle is blocking, the ego vehicle is in the same lane with the platooning
        # and it is close enough, then we regard the back joining finished
        if frontal_lane == ego_vehicle_lane \
                and not vehicle_blocking_status \
                and distance &lt; 1.0 * self._ego_speed / 3.6:
            print(&#39;joining finished !&#39;)
            return (*self.run_step_maintaining(), FSM.JOINING_FINISHED)

        # 4. If vehicle is not blocked, make ego back to the frontal vehicle&#39;s lane
        if not vehicle_blocking_status:
            print(&#39;no vehicle is blocking!!!&#39;)
            if frontal_lane != ego_vehicle_lane:
                left_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_left_lane()
                right_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_right_lane()

                if not left_wpt and not right_wpt:
                    pass
                # if no right lane
                elif not right_wpt:
                    print(&#39;take left lane&#39;)
                    self.set_destination(left_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)
                # if no left lane available
                elif not left_wpt:
                    print(&#39;take right lane&#39;)
                    self.set_destination(right_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)
                # check which lane is closer to the platooning
                elif abs(left_wpt.lane_id - frontal_lane) &lt; abs(right_wpt.lane_id - frontal_lane):
                    print(&#39;take left lane&#39;)
                    self.set_destination(left_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)
                else:
                    print(&#39;take right lane&#39;)
                    self.set_destination(right_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)

        return (*super().run_step(self.tailgate_speed), FSM.BACK_JOINING)

    def run_step_front_joining(self):
        &#34;&#34;&#34;
        Front-joining algorithm
        :return:
        &#34;&#34;&#34;
        _, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
        # get necessary information of the ego vehicle and target vehicle in the platooning
        rear_vehicle = rear_vehicle_manager.vehicle
        rear_lane = self._map.get_waypoint(rear_vehicle.get_location()).lane_id

        # retrieve the platooning&#39;s destination
        platooning_manager, _ = rear_vehicle_manager.v2x_manager.get_platoon_manager()
        rear_destination = platooning_manager.destination

        # retrieve ego vehicle info
        ego_vehicle_loc = self._ego_pos.location
        ego_wpt = self._map.get_waypoint(ego_vehicle_loc)
        ego_vehicle_lane = ego_wpt.lane_id
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(rear_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # if there is a vehicle blocking between, then abandon this joining
        def dist(v):
            return v.get_location().distance(ego_vehicle_loc)

        vehicle_blocking_status = False
        for vehicle in self.obstacle_vehicles:
            vehicle_blocking_status = vehicle_blocking_status or self._collision_check.is_in_range(self._ego_pos,
                                                                                                   rear_vehicle,
                                                                                                   vehicle,
                                                                                                   self._map)
        # if vehicle blocking between ego and platooning, then abandon this joining
        if vehicle_blocking_status:
            print(&#39;abandon front joining&#39;)
            return (*super().run_step(self.max_speed - self.speed_lim_dist), FSM.ABONDON)

        # if the ego vehilce is already behind the platooning
        if angle &lt;= 90:
            print(&#39;transition to other joining&#39;)
            return (*super().run_step(self.tailgate_speed), FSM.SEARCHING)

        # if vehicle is already in the same lane with the platooning
        if ego_vehicle_lane == rear_lane:
            # after in the same lane, no overtake is allowed anymore
            self.overtake_allowed = False

            if not self.destination_changed:
                self.set_destination(ego_wpt.next(4.5)[0].transform.location, rear_destination)
            if distance &lt; self._ego_speed / 3.6 * self.inter_gap * 1.5:
                print(&#39;joining finished&#39;)
                return (*super().run_step(self.max_speed - self.speed_lim_dist), FSM.JOINING_FINISHED)
            else:
                return (*super().run_step(get_speed(rear_vehicle) * 0.95), FSM.FRONT_JOINING)

        # if the ego is too close to the platooning or speed is too slow
        if distance &lt; self._ego_speed / 3.6 * self.inter_gap \
                or self._ego_speed &lt; self.warm_up_speed \
                or angle &lt;= 90 or get_speed(rear_vehicle) &gt; self._ego_speed \
                or self.get_local_planner().lane_change:
            print(&#39;need to speed up before change lane&#39;)
            return (*super().run_step(self.tailgate_speed), FSM.FRONT_JOINING)

        # set destination same as platooning
        if not self.destination_changed:
            print(&#39;destination reset!!!!&#39;)
            self.destination_changed = True
            self.set_destination(ego_wpt.next(4.5)[0].transform.location, rear_destination, clean=True,
                                 clean_history=True)

        # check which lane is closer to operate lane change
        left_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_left_lane()
        right_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_right_lane()
        # check which lane is closer to the platooning
        if not left_wpt and not right_wpt:
            pass
        # check which lane is closer to the platooning
        elif not right_wpt or abs(left_wpt.lane_id - rear_lane) &lt; abs(right_wpt.lane_id - rear_lane):
            print(&#39;take left lane&#39;)
            self.set_destination(left_wpt.transform.location, rear_destination, clean=True)
        else:
            print(&#39;take right lane&#39;)
            self.set_destination(right_wpt.transform.location, rear_destination, clean=True)

        return (*super().run_step(self.tailgate_speed), FSM.FRONT_JOINING)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent"><code class="flex name class">
<span>class <span class="ident">PlatooningBehaviorAgent</span></span>
<span>(</span><span>vehicle, vehicle_manager, v2x_manager, behavior_yaml, platoon_yaml, carla_map)</span>
</code></dt>
<dd>
<div class="desc"><p>The behavior agent for platooning</p>
<p>Construct class
:param vehicle: carla actor todo:remove this later
:param vehicle_manager: vehicle manager of this agent.
:param v2x_manager: communication manager
:param behavior_yaml: configure yaml file for normal behavior agent
:param platoon_yaml:
configure yaml file for platoon behavior agent
:param carla_map: Carla HD Map
:return</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlatooningBehaviorAgent(BehaviorAgent):
    &#34;&#34;&#34;
    The behavior agent for platooning
    &#34;&#34;&#34;

    def __init__(self, vehicle, vehicle_manager, v2x_manager, behavior_yaml, platoon_yaml, carla_map):
        &#34;&#34;&#34;
        Construct class
        :param vehicle: carla actor todo:remove this later
        :param vehicle_manager: vehicle manager of this agent.
        :param v2x_manager: communication manager
        :param behavior_yaml: configure yaml file for normal behavior agent
        :param platoon_yaml:  configure yaml file for platoon behavior agent
        :param carla_map: Carla HD Map
        :return
        &#34;&#34;&#34;

        super(PlatooningBehaviorAgent, self).__init__(vehicle, carla_map, behavior_yaml)

        self.vehicle_manager = weakref.ref(vehicle_manager)()
        # communication manager
        self.v2x_manager = weakref.ref(v2x_manager)()

        # used for gap keeping
        self.inter_gap = platoon_yaml[&#39;inter_gap&#39;]
        # used when open a gap
        self.open_gap = platoon_yaml[&#39;open_gap&#39;]
        # this is used to control gap opening during cooperative joining
        self.current_gap = self.inter_gap

        # used for merging vehicle
        self.destination_changed = False

        # merging vehicle needs to reach this speed before cooperative merge
        self.warm_up_speed = platoon_yaml[&#39;warm_up_speed&#39;]

        # used to calculate performance
        self.debug_helper = PlatoonDebugHelper(self.vehicle.id)
        self.time_gap = 100.0
        self.dist_gap = 100.0

    def run_step(self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True):
        &#34;&#34;&#34;
        Run a single step for navigation under platooning agent. Finite state machine is used to switch between
        different platooning states.
        Args:
            target_speed (float): Target speed in km/h
            collision_detector_enabled (bool): Whether collision detection enabled.
            lane_change_allowed (bool): Whether lane change is allowed.

        Returns:

        &#34;&#34;&#34;
        # reset time gap and distance gap record at the beginning
        self.time_gap = 100.0
        self.dist_gap = 100.0

        status = self.v2x_manager.get_platoon_status()
        # case1: the vehicle is not cda enabled
        if status == FSM.DISABLE:
            return super().run_step(target_speed, collision_detector_enabled)

        # case2: single vehicle keep searching platoon to join
        if status == FSM.SEARCHING:
            find_platoon, min_index, white_list = self.v2x_manager.match_platoon()
            # we only ignore platoon members for collision detection during joining process
            self.white_list = white_list

            # no platoon found, stay in searching status
            if not find_platoon:
                return super().run_step(target_speed, collision_detector_enabled)

            # platoon found and agreement achieved
            front_vehicle, rear_vehicle = self.v2x_manager.get_platoon_front_rear()
            # if no front vehicle, meaning it will be a frontal joining
            if not front_vehicle and rear_vehicle:
                print(&#39;merging vehicle chooses frontal joining&#39;)
                self.v2x_manager.set_platoon_status(FSM.FRONT_JOINING)
            # if front vehicle and rear vehicle both exist
            if front_vehicle and rear_vehicle:
                print(&#34;merging vehicle chooses cut-in joining&#34;)
                self.v2x_manager.set_platoon_status(FSM.MOVE_TO_POINT)
            # if only front vehicle exits
            if front_vehicle and not rear_vehicle:
                print(&#34;merging vehicle chooses back joining&#34;)
                self.v2x_manager.set_platoon_status(FSM.BACK_JOINING)

            return super().run_step(target_speed, collision_detector_enabled)

        # case3.1: the merging vehicle chooses cut-in joining and is moving to the meeting point
        if status == FSM.MOVE_TO_POINT:
            target_speed, target_waypoint, new_status = self.run_step_cut_in_move2point()
            self.v2x_manager.set_platoon_status(new_status)
            return target_speed, target_waypoint
        # case3.2: the merging vehicle chooses cut-in joining and is ready for merging
        if status == FSM.JOINING:
            target_speed, target_waypoint, new_status = self.run_step_cut_in_joining()
            # if joining is finished
            if new_status == FSM.JOINING_FINISHED:
                self.joining_finish_manager()
            return target_speed, target_waypoint

        # case 4: the merging vehicle selects back joining
        if status == FSM.BACK_JOINING:
            target_speed, target_waypoint, new_status = self.run_step_back_joining()
            # if joining is finshed
            if new_status == FSM.JOINING_FINISHED:
                self.joining_finish_manager()
            return target_speed, target_waypoint

        # case 5: the merging vehicle selects frontal joining
        if status == FSM.FRONT_JOINING:
            target_speed, target_waypoint, new_status = self.run_step_front_joining()
            self.v2x_manager.set_platoon_status(new_status)

            # if joining abandoned
            if new_status == FSM.ABONDON:
                self.v2x_manager.set_platoon_status(FSM.SEARCHING)
                _, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
                self.v2x_manager.add_platoon_blacklist(rear_vehicle_manager.v2x_manager.get_platoon_manager()[0].pmid)
            if new_status == FSM.JOINING_FINISHED:
                self.joining_finish_manager(&#39;rear&#39;)

            return target_speed, target_waypoint

        # case 6: leading vehicle behavior
        if status == FSM.LEADING_MODE:
            return super().run_step(target_speed, collision_detector_enabled)

        # case7: maintaining status
        if status == FSM.MAINTINING:
            return self.run_step_maintaining()

        # case8: Open Gap status
        if status == FSM.OPEN_GAP:
            return self.run_step_open_gap()

    def update_information(self, ego_pos, ego_speed, objects):
        &#34;&#34;&#34;
        Update the perception and localization information to the behavior agent.
        Args:
            ego_pos (carla.Transform): ego position from localization module.
            ego_speed (float): km/h, ego speed.
            objects (dictionary): Objects detection results from perception module.
        &#34;&#34;&#34;
        # update localization information
        self._ego_speed = ego_speed
        self._ego_pos = ego_pos
        self.break_distance = self._ego_speed / 3.6 * self.emergency_param
        # update the localization info to trajectory planner
        self.get_local_planner().update_information(ego_pos, ego_speed)

        # current version only consider about vehicles
        obstacle_vehicles = objects[&#39;vehicles&#39;]
        self.obstacle_vehicles = self.white_list_match(obstacle_vehicles)

        # update the debug helper
        self.debug_helper.update(ego_speed, self.ttc, time_gap=self.time_gap, dist_gap=self.dist_gap)

        if self.ignore_traffic_light:
            self.light_state = &#34;Green&#34;
        else:
            # This method also includes stop signs and intersections.
            self.light_state = str(self.vehicle.get_traffic_light_state())

    def joining_finish_manager(self, insert_vehicle=&#39;front&#39;):
        &#34;&#34;&#34;
        Called when a joining is finish to update the platoon manager list.
        :param insert_vehicle: indicate use the front or rear vehicle index to update the platoon manager list.
        :return:
        &#34;&#34;&#34;
        frontal_vehicle_manager, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
        if insert_vehicle == &#39;front&#39;:
            platoon_manger, index = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
            platoon_manger.set_member(self.vehicle_manager, index + 1)
            self._local_planner.debug_trajectory = False
        else:
            platoon_manger, index = rear_vehicle_manager.v2x_manager.get_platoon_manager()
            platoon_manger.set_member(self.vehicle_manager, index, lead=True)

        platoon_manger.update_member_order()

    def calculate_gap(self, distance):
        &#34;&#34;&#34;
        Calculate the current vehicle and frontal vehicle&#39;s time/distance gap
        :param distance:  distance between the ego vehicle and frontal vehicle
        :return:
        &#34;&#34;&#34;
        # we need to count the vehicle length in to calculate the gap
        boundingbox = self.vehicle.bounding_box
        veh_length = 2 * abs(boundingbox.location.y - boundingbox.extent.y)

        delta_v = self._ego_speed / 3.6
        time_gap = distance / delta_v
        self.time_gap = time_gap
        self.dist_gap = distance - veh_length

    def platooning_following_manager(self, inter_gap):
        &#34;&#34;&#34;
        Car following behavior in platooning with gap regulation
        :param inter_gap: the gap designed for platooning
        :return:
        &#34;&#34;&#34;

        frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
        frontal_front_vehicle_manger, _ = frontal_vehicle_manager.v2x_manager.get_platoon_front_rear()

        if len(self._local_planner.get_trajetory()) &gt; self.get_local_planner().trajectory_update_freq - 2:
            return self._local_planner.run_step([], [], [], following=True)
        else:
            # this agent is a behavior agent 
            frontal_trajectory = frontal_vehicle_manager.agent.get_local_planner().get_trajetory()

            # get front speed
            frontal_speed = frontal_vehicle_manager.agent._ego_speed

            ego_trajetory = deque(maxlen=30)
            ego_loc_x, ego_loc_y, ego_loc_z = self._ego_pos.location.x, self._ego_pos.location.y, \
                                              self._ego_pos.location.z

            # get ego speed
            ego_speed = self._ego_speed

            # compare speed with frontal veh
            frontal_speedd_diff = ego_speed - frontal_speed

            tracked_length = len(frontal_trajectory) - 1 if not frontal_front_vehicle_manger \
                else len(frontal_trajectory)

            # todo: current not working well on curve
            for i in range(tracked_length):
                delta_t = self.get_local_planner().dt
                # if leader is slowing down(leader target speed is smaller than current speed), use a bigger dt.
                # spd diff max at 15. If diff greater than 8, increase dt
                if frontal_speedd_diff &gt; 3.0:
                    &#39;&#39;&#39;
                    # only increase dt when V_ego &gt; V_front (avoid collision)
                    # if V_ego &lt; V_front (diff &lt; 0), stick with small dt 
                    # todo: change delta_t to a function: 
                    #      --&gt; 1. {V_ego &gt; V_front}: decrease dt to increase gap, help avoid collision
                    #      --&gt; 2. more difference, more dt adjustment 
                    #      --&gt; 3. {V_ego &lt; V_front}: will not collide, keep default dt to keep gap
                    #      --&gt; 4. {V_ego ~ V_front}: keep default dt to keep gap 
                    &#39;&#39;&#39;
                    delta_t = delta_t + frontal_speedd_diff * 0.0125

                # print(&#39;previous x :%f, delta t: %f&#39; % (frontal_trajectory[i][0].location.x, delta_t))
                if i == 0:
                    pos_x = (frontal_trajectory[i][0].location.x + inter_gap / delta_t * ego_loc_x) / \
                            (1 + inter_gap / delta_t)
                    pos_y = (frontal_trajectory[i][0].location.y + inter_gap / delta_t * ego_loc_y) / \
                            (1 + inter_gap / delta_t)
                else:
                    pos_x = (frontal_trajectory[i][0].location.x +
                             inter_gap / delta_t * ego_trajetory[i - 1][0].location.x) / \
                            (1 + inter_gap / delta_t)
                    pos_y = (frontal_trajectory[i][0].location.y +
                             inter_gap / delta_t * ego_trajetory[i - 1][0].location.y) / \
                            (1 + inter_gap / delta_t)

                distance = np.sqrt((pos_x - ego_loc_x) ** 2 + (pos_y - ego_loc_y) ** 2)
                velocity = distance / delta_t * 3.6
                ego_trajetory.append([carla.Transform(
                    carla.Location(pos_x, pos_y,
                                   self._map.get_waypoint(self._ego_pos.location).transform.location.z)),
                    velocity])

                ego_loc_x = pos_x
                ego_loc_y = pos_y

            if not ego_trajetory:
                wpt = self._map.get_waypoint(self._ego_pos.location)
                next_wpt = wpt.next(max(2, int(self._ego_speed / 3.6 * 1)))[0]
                ego_trajetory.append((next_wpt.transform,
                                      self._ego_speed))

            return self._local_planner.run_step([], [], [], trajectory=ego_trajetory)

    def platooning_merge_management(self, frontal_vehicle_vm):
        &#34;&#34;&#34;
        Merge the vehicle into the platooning
        :param frontal_vehicle_vm:
        :return:
        &#34;&#34;&#34;
        print(&#34;start merging !&#34;)
        self.lane_change_allowed = True
        frontal_vehicle_loc = frontal_vehicle_vm.vehicle.get_location()

        # we choose next waypoint of the frontal vehicle as starting point to have smooth speed
        frontal_vehicle_waypoint = frontal_vehicle_vm.agent._map.get_waypoint(frontal_vehicle_loc)
        frontal_vehicle_next_waypoint = frontal_vehicle_waypoint.next(
            get_speed(frontal_vehicle_vm.vehicle, True))[0].transform.location

        # retrieve the platooning&#39;s destination
        platooning_manager, _ = frontal_vehicle_vm.v2x_manager.get_platoon_manager()
        destination = platooning_manager.destination

        # regenerate route the route to make merge(lane change)
        self.set_destination(frontal_vehicle_next_waypoint, destination, clean=True)

        target_speed, target_waypoint = super().run_step(target_speed=1.5 * get_speed(frontal_vehicle_vm.vehicle),
                                                         collision_detector_enabled=False)

        return target_speed, target_waypoint

    def run_step_maintaining(self):
        &#34;&#34;&#34;
        Behavior planning for speed maintaining
        :return:
        &#34;&#34;&#34;
        frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
        self.current_gap = self.inter_gap

        frontal_vehicle = frontal_vehicle_manager.vehicle
        frontal_vehicle_loc = frontal_vehicle.get_location()
        ego_vehicle_loc = self._ego_pos.location

        # headway distance
        distance = compute_distance(ego_vehicle_loc, frontal_vehicle_loc)
        self.calculate_gap(distance)

        # Distance is computed from the center of the two cars,
        # use bounding boxes to calculate the actual distance
        distance = distance - max(
            frontal_vehicle.bounding_box.extent.y, frontal_vehicle.bounding_box.extent.x) - max(
            self.vehicle.bounding_box.extent.y, self.vehicle.bounding_box.extent.x)

        # safe control for car following todo: make the coefficient controllable
        if distance &lt;= self._ego_speed / 3.6 * 0.01:
            print(&#34;emergency stop!&#34;)
            return 0, None

        target_speed, target_waypoint = self.platooning_following_manager(self.inter_gap)

        return target_speed, target_waypoint

    def run_step_cut_in_move2point(self):
        &#34;&#34;&#34;
        The vehicle is trying to get to the move in point
        :return: target_speed, target_waypoint, next FSM state
        &#34;&#34;&#34;

        frontal_vehicle_manager, rear_vehicle_vm = self.v2x_manager.get_platoon_front_rear()
        frontal_vehicle = frontal_vehicle_manager.vehicle

        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # calculate the time gap with the frontal vehicle
        self.calculate_gap(distance)

        # if there is a obstacle blocking ahead, we just change to back joining mode todo: lane change not considered
        if self.hazard_flag:
            if rear_vehicle_vm:
                rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.MAINTINING)
            # retrieve the last member in the platoon
            platoon_manager, _ = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
            last_member = platoon_manager.vehicle_manager_list[-1]

            # set the last member as the frontal vehicle
            self.v2x_manager.set_platoon_front(last_member)
            self.v2x_manager.set_platoon_rear(None)
            print(&#39;switch to back joining!&#39;)
            # slow down to join back
            return (*super().run_step(self.max_speed / 2), FSM.BACK_JOINING)

        # the vehicle needs to warm up first. But if the platooning is in car following state, then we should ignore
        if self._ego_speed &lt;= self.warm_up_speed and not frontal_vehicle_manager.agent.car_following_flag:
            print(&#34;warming up speed&#34;)
            return (*super().run_step(self.tailgate_speed), FSM.MOVE_TO_POINT)

        # if the ego vehicle is still too far away from the front vehicle
        if distance &gt; self._ego_speed / 3.6 * (self.inter_gap + 0.5) and angle &lt;= 80:
            print(&#39;trying to get the vehicle&#39;)
            return (*super().run_step(2.0 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

        # if the ego vehicle is too close or exceed the frontal vehicle
        if distance &lt; self._ego_speed / 3.6 * self.inter_gap / 1.5 or angle &gt;= 70:
            print(&#39;too close, step back!&#39;)
            return (*super().run_step(0.9 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

        # communicate to the rear vehicle for open gap if rear vehicle exists
        if not rear_vehicle_vm:
            return (*self.platooning_merge_management(frontal_vehicle_manager), FSM.JOINING)

        distance, angle = cal_distance_angle(rear_vehicle_vm.vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # check whether the rear vehicle gives enough gap
        if distance &lt; 1.0 * self.inter_gap / 2.0 * self._ego_speed / 3.6 \
                or angle &lt;= 100 or rear_vehicle_vm.agent.current_gap &lt; self.open_gap:
            # force the rear vehicle open gap for self
            print(&#34;too close to rear vehicle!&#34;)
            rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.OPEN_GAP)
            return (*super().run_step(1.5 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

        return (*self.platooning_merge_management(frontal_vehicle_manager), FSM.JOINING)

    def run_step_cut_in_joining(self):
        &#34;&#34;&#34;
        Check if the vehicle has been joined successfully TODO: Return status instead of True of False
        :return:
        &#34;&#34;&#34;
        print(&#34;merging speed %d&#34; % self._ego_speed)

        frontal_vehicle_manager, rear_vehicle_vm = self.v2x_manager.get_platoon_front_rear()

        frontal_vehicle = frontal_vehicle_manager.vehicle
        frontal_lane = self._map.get_waypoint(frontal_vehicle.get_location()).lane_id

        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_lane = self._map.get_waypoint(ego_vehicle_loc).lane_id
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)
        # calculate the time gap with the frontal vehicle
        self.calculate_gap(distance)

        if frontal_lane == ego_vehicle_lane and angle &lt;= 5:
            print(&#39;merge finished&#39;)
            if rear_vehicle_vm:
                rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.MAINTINING)
            return (*self.run_step_maintaining(), FSM.JOINING_FINISHED)

        return (*super().run_step(target_speed=get_speed(frontal_vehicle),
                                  collision_detector_enabled=False), FSM.JOINING)

    def run_step_open_gap(self):
        &#34;&#34;&#34;
        Open gap for cut-in vehicle
        :return:
        &#34;&#34;&#34;
        frontal_vehicle_manager, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()

        # calculate the time gap under this state
        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, _ = cal_distance_angle(frontal_vehicle_manager.localizer.get_ego_pos().location,
                                         ego_vehicle_loc, ego_vehicle_yaw)
        self.calculate_gap(distance)

        # gradually open the gap TODO: Make this dynamic to map a linear relationship with speed
        if self.current_gap &lt; self.open_gap:
            self.current_gap += 0.01
        print(&#39;cuurent gap is %f&#39; % self.current_gap)
        target_speed, target_loc = self.platooning_following_manager(self.current_gap)

        return target_speed, target_loc

    def run_step_back_joining(self):
        &#34;&#34;&#34;
        Back-joining Algorithm
        :return: control command and whether back joining finished
        &#34;&#34;&#34;
        frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
        # reset lane change flag every step

        # get necessary information of the ego vehicle and target vehicle in the platooning
        frontal_vehicle = frontal_vehicle_manager.vehicle
        frontal_lane = self._map.get_waypoint(frontal_vehicle.get_location()).lane_id

        # retrieve the platooning&#39;s destination
        platooning_manager, _ = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
        frontal_destination = platooning_manager.destination

        # retrieve ego vehicle info todo: remove this later
        ego_vehicle_loc = self._ego_pos.location
        ego_wpt = self._map.get_waypoint(ego_vehicle_loc)
        ego_vehicle_lane = ego_wpt.lane_id
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # calculate the time gap with the frontal vehicle
        self.calculate_gap(distance)

        # 0. make sure the vehicle is behind the ego vehicle
        if angle &gt;= 60 or distance &lt; self._ego_speed / 3.6 * 0.5:
            self.overtake_allowed = False
            print(&#34;angle is too large, wait&#34;)
            return (*super().run_step(get_speed(frontal_vehicle) * 0.90, lane_change_allowed=False), FSM.BACK_JOINING)

        else:
            self.overtake_allowed = True

        # 1. make sure the speed is warmed up first. Also we don&#39;t want to reset destination during lane change
        if self._ego_speed &lt; self.warm_up_speed or self.get_local_planner().lane_change:
            print(&#39;warm up speed&#39;)
            return (*super().run_step(self.tailgate_speed), FSM.BACK_JOINING)

        if not self.destination_changed:
            print(&#39;destination reset!!!!&#39;)
            self.destination_changed = True
            self.set_destination(ego_wpt.next(4.5)[0].transform.location, frontal_destination,
                                 clean=True, clean_history=True)

        # 2. check if there is any other vehicle blocking between ego and platooning
        def dist(v):
            return v.get_location().distance(ego_vehicle_loc)

        vehicle_blocking_status = False
        for vehicle in self.obstacle_vehicles:
            vehicle_blocking_status = vehicle_blocking_status or self._collision_check.is_in_range(self._ego_pos,
                                                                                                   frontal_vehicle,
                                                                                                   vehicle,
                                                                                                   self._map)

        # 3. if no other vehicle is blocking, the ego vehicle is in the same lane with the platooning
        # and it is close enough, then we regard the back joining finished
        if frontal_lane == ego_vehicle_lane \
                and not vehicle_blocking_status \
                and distance &lt; 1.0 * self._ego_speed / 3.6:
            print(&#39;joining finished !&#39;)
            return (*self.run_step_maintaining(), FSM.JOINING_FINISHED)

        # 4. If vehicle is not blocked, make ego back to the frontal vehicle&#39;s lane
        if not vehicle_blocking_status:
            print(&#39;no vehicle is blocking!!!&#39;)
            if frontal_lane != ego_vehicle_lane:
                left_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_left_lane()
                right_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_right_lane()

                if not left_wpt and not right_wpt:
                    pass
                # if no right lane
                elif not right_wpt:
                    print(&#39;take left lane&#39;)
                    self.set_destination(left_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)
                # if no left lane available
                elif not left_wpt:
                    print(&#39;take right lane&#39;)
                    self.set_destination(right_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)
                # check which lane is closer to the platooning
                elif abs(left_wpt.lane_id - frontal_lane) &lt; abs(right_wpt.lane_id - frontal_lane):
                    print(&#39;take left lane&#39;)
                    self.set_destination(left_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)
                else:
                    print(&#39;take right lane&#39;)
                    self.set_destination(right_wpt.transform.location, frontal_destination,
                                         clean=True, clean_history=True)

        return (*super().run_step(self.tailgate_speed), FSM.BACK_JOINING)

    def run_step_front_joining(self):
        &#34;&#34;&#34;
        Front-joining algorithm
        :return:
        &#34;&#34;&#34;
        _, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
        # get necessary information of the ego vehicle and target vehicle in the platooning
        rear_vehicle = rear_vehicle_manager.vehicle
        rear_lane = self._map.get_waypoint(rear_vehicle.get_location()).lane_id

        # retrieve the platooning&#39;s destination
        platooning_manager, _ = rear_vehicle_manager.v2x_manager.get_platoon_manager()
        rear_destination = platooning_manager.destination

        # retrieve ego vehicle info
        ego_vehicle_loc = self._ego_pos.location
        ego_wpt = self._map.get_waypoint(ego_vehicle_loc)
        ego_vehicle_lane = ego_wpt.lane_id
        ego_vehicle_yaw = self._ego_pos.rotation.yaw

        distance, angle = cal_distance_angle(rear_vehicle.get_location(),
                                             ego_vehicle_loc, ego_vehicle_yaw)

        # if there is a vehicle blocking between, then abandon this joining
        def dist(v):
            return v.get_location().distance(ego_vehicle_loc)

        vehicle_blocking_status = False
        for vehicle in self.obstacle_vehicles:
            vehicle_blocking_status = vehicle_blocking_status or self._collision_check.is_in_range(self._ego_pos,
                                                                                                   rear_vehicle,
                                                                                                   vehicle,
                                                                                                   self._map)
        # if vehicle blocking between ego and platooning, then abandon this joining
        if vehicle_blocking_status:
            print(&#39;abandon front joining&#39;)
            return (*super().run_step(self.max_speed - self.speed_lim_dist), FSM.ABONDON)

        # if the ego vehilce is already behind the platooning
        if angle &lt;= 90:
            print(&#39;transition to other joining&#39;)
            return (*super().run_step(self.tailgate_speed), FSM.SEARCHING)

        # if vehicle is already in the same lane with the platooning
        if ego_vehicle_lane == rear_lane:
            # after in the same lane, no overtake is allowed anymore
            self.overtake_allowed = False

            if not self.destination_changed:
                self.set_destination(ego_wpt.next(4.5)[0].transform.location, rear_destination)
            if distance &lt; self._ego_speed / 3.6 * self.inter_gap * 1.5:
                print(&#39;joining finished&#39;)
                return (*super().run_step(self.max_speed - self.speed_lim_dist), FSM.JOINING_FINISHED)
            else:
                return (*super().run_step(get_speed(rear_vehicle) * 0.95), FSM.FRONT_JOINING)

        # if the ego is too close to the platooning or speed is too slow
        if distance &lt; self._ego_speed / 3.6 * self.inter_gap \
                or self._ego_speed &lt; self.warm_up_speed \
                or angle &lt;= 90 or get_speed(rear_vehicle) &gt; self._ego_speed \
                or self.get_local_planner().lane_change:
            print(&#39;need to speed up before change lane&#39;)
            return (*super().run_step(self.tailgate_speed), FSM.FRONT_JOINING)

        # set destination same as platooning
        if not self.destination_changed:
            print(&#39;destination reset!!!!&#39;)
            self.destination_changed = True
            self.set_destination(ego_wpt.next(4.5)[0].transform.location, rear_destination, clean=True,
                                 clean_history=True)

        # check which lane is closer to operate lane change
        left_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_left_lane()
        right_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_right_lane()
        # check which lane is closer to the platooning
        if not left_wpt and not right_wpt:
            pass
        # check which lane is closer to the platooning
        elif not right_wpt or abs(left_wpt.lane_id - rear_lane) &lt; abs(right_wpt.lane_id - rear_lane):
            print(&#39;take left lane&#39;)
            self.set_destination(left_wpt.transform.location, rear_destination, clean=True)
        else:
            print(&#39;take right lane&#39;)
            self.set_destination(right_wpt.transform.location, rear_destination, clean=True)

        return (*super().run_step(self.tailgate_speed), FSM.FRONT_JOINING)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opencda.core.plan.behavior_agent.BehaviorAgent" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent">BehaviorAgent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.calculate_gap"><code class="name flex">
<span>def <span class="ident">calculate_gap</span></span>(<span>self, distance)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the current vehicle and frontal vehicle's time/distance gap
:param distance:
distance between the ego vehicle and frontal vehicle
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_gap(self, distance):
    &#34;&#34;&#34;
    Calculate the current vehicle and frontal vehicle&#39;s time/distance gap
    :param distance:  distance between the ego vehicle and frontal vehicle
    :return:
    &#34;&#34;&#34;
    # we need to count the vehicle length in to calculate the gap
    boundingbox = self.vehicle.bounding_box
    veh_length = 2 * abs(boundingbox.location.y - boundingbox.extent.y)

    delta_v = self._ego_speed / 3.6
    time_gap = distance / delta_v
    self.time_gap = time_gap
    self.dist_gap = distance - veh_length</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.joining_finish_manager"><code class="name flex">
<span>def <span class="ident">joining_finish_manager</span></span>(<span>self, insert_vehicle='front')</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a joining is finish to update the platoon manager list.
:param insert_vehicle: indicate use the front or rear vehicle index to update the platoon manager list.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joining_finish_manager(self, insert_vehicle=&#39;front&#39;):
    &#34;&#34;&#34;
    Called when a joining is finish to update the platoon manager list.
    :param insert_vehicle: indicate use the front or rear vehicle index to update the platoon manager list.
    :return:
    &#34;&#34;&#34;
    frontal_vehicle_manager, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
    if insert_vehicle == &#39;front&#39;:
        platoon_manger, index = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
        platoon_manger.set_member(self.vehicle_manager, index + 1)
        self._local_planner.debug_trajectory = False
    else:
        platoon_manger, index = rear_vehicle_manager.v2x_manager.get_platoon_manager()
        platoon_manger.set_member(self.vehicle_manager, index, lead=True)

    platoon_manger.update_member_order()</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.platooning_following_manager"><code class="name flex">
<span>def <span class="ident">platooning_following_manager</span></span>(<span>self, inter_gap)</span>
</code></dt>
<dd>
<div class="desc"><p>Car following behavior in platooning with gap regulation
:param inter_gap: the gap designed for platooning
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def platooning_following_manager(self, inter_gap):
    &#34;&#34;&#34;
    Car following behavior in platooning with gap regulation
    :param inter_gap: the gap designed for platooning
    :return:
    &#34;&#34;&#34;

    frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
    frontal_front_vehicle_manger, _ = frontal_vehicle_manager.v2x_manager.get_platoon_front_rear()

    if len(self._local_planner.get_trajetory()) &gt; self.get_local_planner().trajectory_update_freq - 2:
        return self._local_planner.run_step([], [], [], following=True)
    else:
        # this agent is a behavior agent 
        frontal_trajectory = frontal_vehicle_manager.agent.get_local_planner().get_trajetory()

        # get front speed
        frontal_speed = frontal_vehicle_manager.agent._ego_speed

        ego_trajetory = deque(maxlen=30)
        ego_loc_x, ego_loc_y, ego_loc_z = self._ego_pos.location.x, self._ego_pos.location.y, \
                                          self._ego_pos.location.z

        # get ego speed
        ego_speed = self._ego_speed

        # compare speed with frontal veh
        frontal_speedd_diff = ego_speed - frontal_speed

        tracked_length = len(frontal_trajectory) - 1 if not frontal_front_vehicle_manger \
            else len(frontal_trajectory)

        # todo: current not working well on curve
        for i in range(tracked_length):
            delta_t = self.get_local_planner().dt
            # if leader is slowing down(leader target speed is smaller than current speed), use a bigger dt.
            # spd diff max at 15. If diff greater than 8, increase dt
            if frontal_speedd_diff &gt; 3.0:
                &#39;&#39;&#39;
                # only increase dt when V_ego &gt; V_front (avoid collision)
                # if V_ego &lt; V_front (diff &lt; 0), stick with small dt 
                # todo: change delta_t to a function: 
                #      --&gt; 1. {V_ego &gt; V_front}: decrease dt to increase gap, help avoid collision
                #      --&gt; 2. more difference, more dt adjustment 
                #      --&gt; 3. {V_ego &lt; V_front}: will not collide, keep default dt to keep gap
                #      --&gt; 4. {V_ego ~ V_front}: keep default dt to keep gap 
                &#39;&#39;&#39;
                delta_t = delta_t + frontal_speedd_diff * 0.0125

            # print(&#39;previous x :%f, delta t: %f&#39; % (frontal_trajectory[i][0].location.x, delta_t))
            if i == 0:
                pos_x = (frontal_trajectory[i][0].location.x + inter_gap / delta_t * ego_loc_x) / \
                        (1 + inter_gap / delta_t)
                pos_y = (frontal_trajectory[i][0].location.y + inter_gap / delta_t * ego_loc_y) / \
                        (1 + inter_gap / delta_t)
            else:
                pos_x = (frontal_trajectory[i][0].location.x +
                         inter_gap / delta_t * ego_trajetory[i - 1][0].location.x) / \
                        (1 + inter_gap / delta_t)
                pos_y = (frontal_trajectory[i][0].location.y +
                         inter_gap / delta_t * ego_trajetory[i - 1][0].location.y) / \
                        (1 + inter_gap / delta_t)

            distance = np.sqrt((pos_x - ego_loc_x) ** 2 + (pos_y - ego_loc_y) ** 2)
            velocity = distance / delta_t * 3.6
            ego_trajetory.append([carla.Transform(
                carla.Location(pos_x, pos_y,
                               self._map.get_waypoint(self._ego_pos.location).transform.location.z)),
                velocity])

            ego_loc_x = pos_x
            ego_loc_y = pos_y

        if not ego_trajetory:
            wpt = self._map.get_waypoint(self._ego_pos.location)
            next_wpt = wpt.next(max(2, int(self._ego_speed / 3.6 * 1)))[0]
            ego_trajetory.append((next_wpt.transform,
                                  self._ego_speed))

        return self._local_planner.run_step([], [], [], trajectory=ego_trajetory)</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.platooning_merge_management"><code class="name flex">
<span>def <span class="ident">platooning_merge_management</span></span>(<span>self, frontal_vehicle_vm)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge the vehicle into the platooning
:param frontal_vehicle_vm:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def platooning_merge_management(self, frontal_vehicle_vm):
    &#34;&#34;&#34;
    Merge the vehicle into the platooning
    :param frontal_vehicle_vm:
    :return:
    &#34;&#34;&#34;
    print(&#34;start merging !&#34;)
    self.lane_change_allowed = True
    frontal_vehicle_loc = frontal_vehicle_vm.vehicle.get_location()

    # we choose next waypoint of the frontal vehicle as starting point to have smooth speed
    frontal_vehicle_waypoint = frontal_vehicle_vm.agent._map.get_waypoint(frontal_vehicle_loc)
    frontal_vehicle_next_waypoint = frontal_vehicle_waypoint.next(
        get_speed(frontal_vehicle_vm.vehicle, True))[0].transform.location

    # retrieve the platooning&#39;s destination
    platooning_manager, _ = frontal_vehicle_vm.v2x_manager.get_platoon_manager()
    destination = platooning_manager.destination

    # regenerate route the route to make merge(lane change)
    self.set_destination(frontal_vehicle_next_waypoint, destination, clean=True)

    target_speed, target_waypoint = super().run_step(target_speed=1.5 * get_speed(frontal_vehicle_vm.vehicle),
                                                     collision_detector_enabled=False)

    return target_speed, target_waypoint</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step"><code class="name flex">
<span>def <span class="ident">run_step</span></span>(<span>self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a single step for navigation under platooning agent. Finite state machine is used to switch between
different platooning states.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_speed</code></strong> :&ensp;<code>float</code></dt>
<dd>Target speed in km/h</dd>
<dt><strong><code>collision_detector_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether collision detection enabled.</dd>
<dt><strong><code>lane_change_allowed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether lane change is allowed.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step(self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True):
    &#34;&#34;&#34;
    Run a single step for navigation under platooning agent. Finite state machine is used to switch between
    different platooning states.
    Args:
        target_speed (float): Target speed in km/h
        collision_detector_enabled (bool): Whether collision detection enabled.
        lane_change_allowed (bool): Whether lane change is allowed.

    Returns:

    &#34;&#34;&#34;
    # reset time gap and distance gap record at the beginning
    self.time_gap = 100.0
    self.dist_gap = 100.0

    status = self.v2x_manager.get_platoon_status()
    # case1: the vehicle is not cda enabled
    if status == FSM.DISABLE:
        return super().run_step(target_speed, collision_detector_enabled)

    # case2: single vehicle keep searching platoon to join
    if status == FSM.SEARCHING:
        find_platoon, min_index, white_list = self.v2x_manager.match_platoon()
        # we only ignore platoon members for collision detection during joining process
        self.white_list = white_list

        # no platoon found, stay in searching status
        if not find_platoon:
            return super().run_step(target_speed, collision_detector_enabled)

        # platoon found and agreement achieved
        front_vehicle, rear_vehicle = self.v2x_manager.get_platoon_front_rear()
        # if no front vehicle, meaning it will be a frontal joining
        if not front_vehicle and rear_vehicle:
            print(&#39;merging vehicle chooses frontal joining&#39;)
            self.v2x_manager.set_platoon_status(FSM.FRONT_JOINING)
        # if front vehicle and rear vehicle both exist
        if front_vehicle and rear_vehicle:
            print(&#34;merging vehicle chooses cut-in joining&#34;)
            self.v2x_manager.set_platoon_status(FSM.MOVE_TO_POINT)
        # if only front vehicle exits
        if front_vehicle and not rear_vehicle:
            print(&#34;merging vehicle chooses back joining&#34;)
            self.v2x_manager.set_platoon_status(FSM.BACK_JOINING)

        return super().run_step(target_speed, collision_detector_enabled)

    # case3.1: the merging vehicle chooses cut-in joining and is moving to the meeting point
    if status == FSM.MOVE_TO_POINT:
        target_speed, target_waypoint, new_status = self.run_step_cut_in_move2point()
        self.v2x_manager.set_platoon_status(new_status)
        return target_speed, target_waypoint
    # case3.2: the merging vehicle chooses cut-in joining and is ready for merging
    if status == FSM.JOINING:
        target_speed, target_waypoint, new_status = self.run_step_cut_in_joining()
        # if joining is finished
        if new_status == FSM.JOINING_FINISHED:
            self.joining_finish_manager()
        return target_speed, target_waypoint

    # case 4: the merging vehicle selects back joining
    if status == FSM.BACK_JOINING:
        target_speed, target_waypoint, new_status = self.run_step_back_joining()
        # if joining is finshed
        if new_status == FSM.JOINING_FINISHED:
            self.joining_finish_manager()
        return target_speed, target_waypoint

    # case 5: the merging vehicle selects frontal joining
    if status == FSM.FRONT_JOINING:
        target_speed, target_waypoint, new_status = self.run_step_front_joining()
        self.v2x_manager.set_platoon_status(new_status)

        # if joining abandoned
        if new_status == FSM.ABONDON:
            self.v2x_manager.set_platoon_status(FSM.SEARCHING)
            _, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
            self.v2x_manager.add_platoon_blacklist(rear_vehicle_manager.v2x_manager.get_platoon_manager()[0].pmid)
        if new_status == FSM.JOINING_FINISHED:
            self.joining_finish_manager(&#39;rear&#39;)

        return target_speed, target_waypoint

    # case 6: leading vehicle behavior
    if status == FSM.LEADING_MODE:
        return super().run_step(target_speed, collision_detector_enabled)

    # case7: maintaining status
    if status == FSM.MAINTINING:
        return self.run_step_maintaining()

    # case8: Open Gap status
    if status == FSM.OPEN_GAP:
        return self.run_step_open_gap()</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_back_joining"><code class="name flex">
<span>def <span class="ident">run_step_back_joining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Back-joining Algorithm
:return: control command and whether back joining finished</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step_back_joining(self):
    &#34;&#34;&#34;
    Back-joining Algorithm
    :return: control command and whether back joining finished
    &#34;&#34;&#34;
    frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
    # reset lane change flag every step

    # get necessary information of the ego vehicle and target vehicle in the platooning
    frontal_vehicle = frontal_vehicle_manager.vehicle
    frontal_lane = self._map.get_waypoint(frontal_vehicle.get_location()).lane_id

    # retrieve the platooning&#39;s destination
    platooning_manager, _ = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
    frontal_destination = platooning_manager.destination

    # retrieve ego vehicle info todo: remove this later
    ego_vehicle_loc = self._ego_pos.location
    ego_wpt = self._map.get_waypoint(ego_vehicle_loc)
    ego_vehicle_lane = ego_wpt.lane_id
    ego_vehicle_yaw = self._ego_pos.rotation.yaw

    distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                         ego_vehicle_loc, ego_vehicle_yaw)

    # calculate the time gap with the frontal vehicle
    self.calculate_gap(distance)

    # 0. make sure the vehicle is behind the ego vehicle
    if angle &gt;= 60 or distance &lt; self._ego_speed / 3.6 * 0.5:
        self.overtake_allowed = False
        print(&#34;angle is too large, wait&#34;)
        return (*super().run_step(get_speed(frontal_vehicle) * 0.90, lane_change_allowed=False), FSM.BACK_JOINING)

    else:
        self.overtake_allowed = True

    # 1. make sure the speed is warmed up first. Also we don&#39;t want to reset destination during lane change
    if self._ego_speed &lt; self.warm_up_speed or self.get_local_planner().lane_change:
        print(&#39;warm up speed&#39;)
        return (*super().run_step(self.tailgate_speed), FSM.BACK_JOINING)

    if not self.destination_changed:
        print(&#39;destination reset!!!!&#39;)
        self.destination_changed = True
        self.set_destination(ego_wpt.next(4.5)[0].transform.location, frontal_destination,
                             clean=True, clean_history=True)

    # 2. check if there is any other vehicle blocking between ego and platooning
    def dist(v):
        return v.get_location().distance(ego_vehicle_loc)

    vehicle_blocking_status = False
    for vehicle in self.obstacle_vehicles:
        vehicle_blocking_status = vehicle_blocking_status or self._collision_check.is_in_range(self._ego_pos,
                                                                                               frontal_vehicle,
                                                                                               vehicle,
                                                                                               self._map)

    # 3. if no other vehicle is blocking, the ego vehicle is in the same lane with the platooning
    # and it is close enough, then we regard the back joining finished
    if frontal_lane == ego_vehicle_lane \
            and not vehicle_blocking_status \
            and distance &lt; 1.0 * self._ego_speed / 3.6:
        print(&#39;joining finished !&#39;)
        return (*self.run_step_maintaining(), FSM.JOINING_FINISHED)

    # 4. If vehicle is not blocked, make ego back to the frontal vehicle&#39;s lane
    if not vehicle_blocking_status:
        print(&#39;no vehicle is blocking!!!&#39;)
        if frontal_lane != ego_vehicle_lane:
            left_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_left_lane()
            right_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_right_lane()

            if not left_wpt and not right_wpt:
                pass
            # if no right lane
            elif not right_wpt:
                print(&#39;take left lane&#39;)
                self.set_destination(left_wpt.transform.location, frontal_destination,
                                     clean=True, clean_history=True)
            # if no left lane available
            elif not left_wpt:
                print(&#39;take right lane&#39;)
                self.set_destination(right_wpt.transform.location, frontal_destination,
                                     clean=True, clean_history=True)
            # check which lane is closer to the platooning
            elif abs(left_wpt.lane_id - frontal_lane) &lt; abs(right_wpt.lane_id - frontal_lane):
                print(&#39;take left lane&#39;)
                self.set_destination(left_wpt.transform.location, frontal_destination,
                                     clean=True, clean_history=True)
            else:
                print(&#39;take right lane&#39;)
                self.set_destination(right_wpt.transform.location, frontal_destination,
                                     clean=True, clean_history=True)

    return (*super().run_step(self.tailgate_speed), FSM.BACK_JOINING)</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_cut_in_joining"><code class="name flex">
<span>def <span class="ident">run_step_cut_in_joining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the vehicle has been joined successfully TODO: Return status instead of True of False
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step_cut_in_joining(self):
    &#34;&#34;&#34;
    Check if the vehicle has been joined successfully TODO: Return status instead of True of False
    :return:
    &#34;&#34;&#34;
    print(&#34;merging speed %d&#34; % self._ego_speed)

    frontal_vehicle_manager, rear_vehicle_vm = self.v2x_manager.get_platoon_front_rear()

    frontal_vehicle = frontal_vehicle_manager.vehicle
    frontal_lane = self._map.get_waypoint(frontal_vehicle.get_location()).lane_id

    ego_vehicle_loc = self._ego_pos.location
    ego_vehicle_lane = self._map.get_waypoint(ego_vehicle_loc).lane_id
    ego_vehicle_yaw = self._ego_pos.rotation.yaw

    distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                         ego_vehicle_loc, ego_vehicle_yaw)
    # calculate the time gap with the frontal vehicle
    self.calculate_gap(distance)

    if frontal_lane == ego_vehicle_lane and angle &lt;= 5:
        print(&#39;merge finished&#39;)
        if rear_vehicle_vm:
            rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.MAINTINING)
        return (*self.run_step_maintaining(), FSM.JOINING_FINISHED)

    return (*super().run_step(target_speed=get_speed(frontal_vehicle),
                              collision_detector_enabled=False), FSM.JOINING)</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_cut_in_move2point"><code class="name flex">
<span>def <span class="ident">run_step_cut_in_move2point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The vehicle is trying to get to the move in point
:return: target_speed, target_waypoint, next FSM state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step_cut_in_move2point(self):
    &#34;&#34;&#34;
    The vehicle is trying to get to the move in point
    :return: target_speed, target_waypoint, next FSM state
    &#34;&#34;&#34;

    frontal_vehicle_manager, rear_vehicle_vm = self.v2x_manager.get_platoon_front_rear()
    frontal_vehicle = frontal_vehicle_manager.vehicle

    ego_vehicle_loc = self._ego_pos.location
    ego_vehicle_yaw = self._ego_pos.rotation.yaw

    distance, angle = cal_distance_angle(frontal_vehicle.get_location(),
                                         ego_vehicle_loc, ego_vehicle_yaw)

    # calculate the time gap with the frontal vehicle
    self.calculate_gap(distance)

    # if there is a obstacle blocking ahead, we just change to back joining mode todo: lane change not considered
    if self.hazard_flag:
        if rear_vehicle_vm:
            rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.MAINTINING)
        # retrieve the last member in the platoon
        platoon_manager, _ = frontal_vehicle_manager.v2x_manager.get_platoon_manager()
        last_member = platoon_manager.vehicle_manager_list[-1]

        # set the last member as the frontal vehicle
        self.v2x_manager.set_platoon_front(last_member)
        self.v2x_manager.set_platoon_rear(None)
        print(&#39;switch to back joining!&#39;)
        # slow down to join back
        return (*super().run_step(self.max_speed / 2), FSM.BACK_JOINING)

    # the vehicle needs to warm up first. But if the platooning is in car following state, then we should ignore
    if self._ego_speed &lt;= self.warm_up_speed and not frontal_vehicle_manager.agent.car_following_flag:
        print(&#34;warming up speed&#34;)
        return (*super().run_step(self.tailgate_speed), FSM.MOVE_TO_POINT)

    # if the ego vehicle is still too far away from the front vehicle
    if distance &gt; self._ego_speed / 3.6 * (self.inter_gap + 0.5) and angle &lt;= 80:
        print(&#39;trying to get the vehicle&#39;)
        return (*super().run_step(2.0 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

    # if the ego vehicle is too close or exceed the frontal vehicle
    if distance &lt; self._ego_speed / 3.6 * self.inter_gap / 1.5 or angle &gt;= 70:
        print(&#39;too close, step back!&#39;)
        return (*super().run_step(0.9 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

    # communicate to the rear vehicle for open gap if rear vehicle exists
    if not rear_vehicle_vm:
        return (*self.platooning_merge_management(frontal_vehicle_manager), FSM.JOINING)

    distance, angle = cal_distance_angle(rear_vehicle_vm.vehicle.get_location(),
                                         ego_vehicle_loc, ego_vehicle_yaw)

    # check whether the rear vehicle gives enough gap
    if distance &lt; 1.0 * self.inter_gap / 2.0 * self._ego_speed / 3.6 \
            or angle &lt;= 100 or rear_vehicle_vm.agent.current_gap &lt; self.open_gap:
        # force the rear vehicle open gap for self
        print(&#34;too close to rear vehicle!&#34;)
        rear_vehicle_vm.v2x_manager.set_platoon_status(FSM.OPEN_GAP)
        return (*super().run_step(1.5 * get_speed(frontal_vehicle)), FSM.MOVE_TO_POINT)

    return (*self.platooning_merge_management(frontal_vehicle_manager), FSM.JOINING)</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_front_joining"><code class="name flex">
<span>def <span class="ident">run_step_front_joining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Front-joining algorithm
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step_front_joining(self):
    &#34;&#34;&#34;
    Front-joining algorithm
    :return:
    &#34;&#34;&#34;
    _, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()
    # get necessary information of the ego vehicle and target vehicle in the platooning
    rear_vehicle = rear_vehicle_manager.vehicle
    rear_lane = self._map.get_waypoint(rear_vehicle.get_location()).lane_id

    # retrieve the platooning&#39;s destination
    platooning_manager, _ = rear_vehicle_manager.v2x_manager.get_platoon_manager()
    rear_destination = platooning_manager.destination

    # retrieve ego vehicle info
    ego_vehicle_loc = self._ego_pos.location
    ego_wpt = self._map.get_waypoint(ego_vehicle_loc)
    ego_vehicle_lane = ego_wpt.lane_id
    ego_vehicle_yaw = self._ego_pos.rotation.yaw

    distance, angle = cal_distance_angle(rear_vehicle.get_location(),
                                         ego_vehicle_loc, ego_vehicle_yaw)

    # if there is a vehicle blocking between, then abandon this joining
    def dist(v):
        return v.get_location().distance(ego_vehicle_loc)

    vehicle_blocking_status = False
    for vehicle in self.obstacle_vehicles:
        vehicle_blocking_status = vehicle_blocking_status or self._collision_check.is_in_range(self._ego_pos,
                                                                                               rear_vehicle,
                                                                                               vehicle,
                                                                                               self._map)
    # if vehicle blocking between ego and platooning, then abandon this joining
    if vehicle_blocking_status:
        print(&#39;abandon front joining&#39;)
        return (*super().run_step(self.max_speed - self.speed_lim_dist), FSM.ABONDON)

    # if the ego vehilce is already behind the platooning
    if angle &lt;= 90:
        print(&#39;transition to other joining&#39;)
        return (*super().run_step(self.tailgate_speed), FSM.SEARCHING)

    # if vehicle is already in the same lane with the platooning
    if ego_vehicle_lane == rear_lane:
        # after in the same lane, no overtake is allowed anymore
        self.overtake_allowed = False

        if not self.destination_changed:
            self.set_destination(ego_wpt.next(4.5)[0].transform.location, rear_destination)
        if distance &lt; self._ego_speed / 3.6 * self.inter_gap * 1.5:
            print(&#39;joining finished&#39;)
            return (*super().run_step(self.max_speed - self.speed_lim_dist), FSM.JOINING_FINISHED)
        else:
            return (*super().run_step(get_speed(rear_vehicle) * 0.95), FSM.FRONT_JOINING)

    # if the ego is too close to the platooning or speed is too slow
    if distance &lt; self._ego_speed / 3.6 * self.inter_gap \
            or self._ego_speed &lt; self.warm_up_speed \
            or angle &lt;= 90 or get_speed(rear_vehicle) &gt; self._ego_speed \
            or self.get_local_planner().lane_change:
        print(&#39;need to speed up before change lane&#39;)
        return (*super().run_step(self.tailgate_speed), FSM.FRONT_JOINING)

    # set destination same as platooning
    if not self.destination_changed:
        print(&#39;destination reset!!!!&#39;)
        self.destination_changed = True
        self.set_destination(ego_wpt.next(4.5)[0].transform.location, rear_destination, clean=True,
                             clean_history=True)

    # check which lane is closer to operate lane change
    left_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_left_lane()
    right_wpt = ego_wpt.next(max(1.2 * self._ego_speed / 3.6, 5))[0].get_right_lane()
    # check which lane is closer to the platooning
    if not left_wpt and not right_wpt:
        pass
    # check which lane is closer to the platooning
    elif not right_wpt or abs(left_wpt.lane_id - rear_lane) &lt; abs(right_wpt.lane_id - rear_lane):
        print(&#39;take left lane&#39;)
        self.set_destination(left_wpt.transform.location, rear_destination, clean=True)
    else:
        print(&#39;take right lane&#39;)
        self.set_destination(right_wpt.transform.location, rear_destination, clean=True)

    return (*super().run_step(self.tailgate_speed), FSM.FRONT_JOINING)</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_maintaining"><code class="name flex">
<span>def <span class="ident">run_step_maintaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Behavior planning for speed maintaining
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step_maintaining(self):
    &#34;&#34;&#34;
    Behavior planning for speed maintaining
    :return:
    &#34;&#34;&#34;
    frontal_vehicle_manager, _ = self.v2x_manager.get_platoon_front_rear()
    self.current_gap = self.inter_gap

    frontal_vehicle = frontal_vehicle_manager.vehicle
    frontal_vehicle_loc = frontal_vehicle.get_location()
    ego_vehicle_loc = self._ego_pos.location

    # headway distance
    distance = compute_distance(ego_vehicle_loc, frontal_vehicle_loc)
    self.calculate_gap(distance)

    # Distance is computed from the center of the two cars,
    # use bounding boxes to calculate the actual distance
    distance = distance - max(
        frontal_vehicle.bounding_box.extent.y, frontal_vehicle.bounding_box.extent.x) - max(
        self.vehicle.bounding_box.extent.y, self.vehicle.bounding_box.extent.x)

    # safe control for car following todo: make the coefficient controllable
    if distance &lt;= self._ego_speed / 3.6 * 0.01:
        print(&#34;emergency stop!&#34;)
        return 0, None

    target_speed, target_waypoint = self.platooning_following_manager(self.inter_gap)

    return target_speed, target_waypoint</code></pre>
</details>
</dd>
<dt id="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_open_gap"><code class="name flex">
<span>def <span class="ident">run_step_open_gap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Open gap for cut-in vehicle
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step_open_gap(self):
    &#34;&#34;&#34;
    Open gap for cut-in vehicle
    :return:
    &#34;&#34;&#34;
    frontal_vehicle_manager, rear_vehicle_manager = self.v2x_manager.get_platoon_front_rear()

    # calculate the time gap under this state
    ego_vehicle_loc = self._ego_pos.location
    ego_vehicle_yaw = self._ego_pos.rotation.yaw

    distance, _ = cal_distance_angle(frontal_vehicle_manager.localizer.get_ego_pos().location,
                                     ego_vehicle_loc, ego_vehicle_yaw)
    self.calculate_gap(distance)

    # gradually open the gap TODO: Make this dynamic to map a linear relationship with speed
    if self.current_gap &lt; self.open_gap:
        self.current_gap += 0.01
    print(&#39;cuurent gap is %f&#39; % self.current_gap)
    target_speed, target_loc = self.platooning_following_manager(self.current_gap)

    return target_speed, target_loc</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="opencda.core.plan.behavior_agent.BehaviorAgent" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent">BehaviorAgent</a></b></code>:
<ul class="hlist">
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.add_white_list" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.add_white_list">add_white_list</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.car_following_manager" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.car_following_manager">car_following_manager</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.collision_manager" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.collision_manager">collision_manager</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.get_local_planner" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.get_local_planner">get_local_planner</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.lane_change_management" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.lane_change_management">lane_change_management</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.overtake_management" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.overtake_management">overtake_management</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.reroute" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.reroute">reroute</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.set_destination" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.set_destination">set_destination</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.traffic_light_manager" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.traffic_light_manager">traffic_light_manager</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.update_information" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.update_information">update_information</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.white_list_match" href="../../plan/behavior_agent.html#opencda.core.plan.behavior_agent.BehaviorAgent.white_list_match">white_list_match</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opencda.core.application.platooning" href="index.html">opencda.core.application.platooning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent">PlatooningBehaviorAgent</a></code></h4>
<ul class="">
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.calculate_gap" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.calculate_gap">calculate_gap</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.joining_finish_manager" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.joining_finish_manager">joining_finish_manager</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.platooning_following_manager" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.platooning_following_manager">platooning_following_manager</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.platooning_merge_management" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.platooning_merge_management">platooning_merge_management</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step">run_step</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_back_joining" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_back_joining">run_step_back_joining</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_cut_in_joining" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_cut_in_joining">run_step_cut_in_joining</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_cut_in_move2point" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_cut_in_move2point">run_step_cut_in_move2point</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_front_joining" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_front_joining">run_step_front_joining</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_maintaining" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_maintaining">run_step_maintaining</a></code></li>
<li><code><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_open_gap" href="#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent.run_step_open_gap">run_step_open_gap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
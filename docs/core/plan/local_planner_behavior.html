<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>opencda.core.plan.local_planner_behavior API documentation</title>
<meta name="description" content="This module contains a local planner to perform
low-level waypoint following based on PID controllers." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>opencda.core.plan.local_planner_behavior</code></h1>
</header>
<section id="section-intro">
<p>This module contains a local planner to perform
low-level waypoint following based on PID controllers.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34; This module contains a local planner to perform
low-level waypoint following based on PID controllers. &#34;&#34;&#34;

# Author: Runsheng Xu &lt;rxx3386@ucla.edu&gt;
# License: MIT

from collections import deque
from enum import Enum
import statistics
import math

import carla
import numpy as np

from opencda.core.common.misc import distance_vehicle, draw_trajetory_points, cal_distance_angle
from opencda.core.plan.spline import Spline2D


class RoadOption(Enum):
    &#34;&#34;&#34;
    RoadOption represents the possible topological configurations
    when moving from a segment of lane to other.
    &#34;&#34;&#34;
    VOID = -1
    LEFT = 1
    RIGHT = 2
    STRAIGHT = 3
    LANEFOLLOW = 4
    CHANGELANELEFT = 5
    CHANGELANERIGHT = 6


class LocalPlanner(object):
    &#34;&#34;&#34;
    LocalPlanner implements the basic behavior of following a trajectory
    of waypoints that is generated on-the-fly.
    The low-level motion of the vehicle is computed by using two PID controllers,
    one is used for the lateral control
    and the other for the longitudinal control (cruise speed).

    When multiple paths are available (intersections)
    this local planner makes a random choice.
    &#34;&#34;&#34;

    # Minimum distance to target waypoint as a percentage
    # (e.g. within 80% of total distance)

    def __init__(self, agent, carla_map, config_yaml):
        &#34;&#34;&#34;
        :param agent: agent that regulates the vehicle
        :param config_yaml: local planner configuration file
        &#34;&#34;&#34;
        self._vehicle = agent.vehicle
        self._map = carla_map

        self._ego_pos = None
        self._ego_speed = None

        # waypoint pop out thresholding
        self._min_distance = config_yaml[&#39;min_dist&#39;]
        self._buffer_size = config_yaml[&#39;buffer_size&#39;]

        # TODO: pid controller should be outside
        self._pid_controller = None

        # global route
        self.waypoints_queue = deque(maxlen=20000)
        # waypoint route
        self._waypoint_buffer = deque(maxlen=self._buffer_size)
        # trajectory buffer
        self._long_plan_debug = []
        self._trajectory_buffer = deque(maxlen=30)
        self._history_buffer = deque(maxlen=3)
        self.trajectory_update_freq = config_yaml[&#39;trajectory_update_freq&#39;]

        # trajectory sampling rate
        self.dt = config_yaml[&#39;trajectory_dt&#39;]

        # used to identify whether lane change is operated
        self.lane_change = False
        # In some corner cases, the id is not changed but we regard it as lane change due to large lateral diff
        self.lane_id_change = False

        # debug option
        self.debug = config_yaml[&#39;debug&#39;]
        self.debug_trajectory = config_yaml[&#39;debug_trajectory&#39;]

    def set_global_plan(self, current_plan, clean=False):
        &#34;&#34;&#34;
        Sets new global plan.

            :param clean:
            :param current_plan: list of waypoints in the actual plan
        &#34;&#34;&#34;
        for elem in current_plan:
            self.waypoints_queue.append(elem)

        if clean:
            self._waypoint_buffer.clear()
            for _ in range(self._buffer_size):
                if self.waypoints_queue:
                    self._waypoint_buffer.append(
                        self.waypoints_queue.popleft())
                else:
                    break

    def update_information(self, ego_pos, ego_speed):
        &#34;&#34;&#34;
        Update the ego position and speed for trajectory planner.
        Args:
            ego_pos (carla.Transform): Ego position from localization module.
            ego_speed (float): Ego speed(km/h) from localization module.

        Returns:

        &#34;&#34;&#34;
        self._ego_pos = ego_pos
        self._ego_speed = ego_speed

    def get_trajetory(self):
        &#34;&#34;&#34;
        Get the trajetory
        :return:
        &#34;&#34;&#34;
        return self._trajectory_buffer

    def generate_path(self):
        &#34;&#34;&#34;
        Generate the smooth path using cubic spline
        :return: rx, ry, ryaw, rk: list of planned path points&#39; x,y coordinates, yaw angle and curvature
        &#34;&#34;&#34;

        # used to save all key spline node
        x = []
        y = []

        # [m] distance of each interpolated points
        ds = 0.1

        # retrieve current location, yaw angle todo: this should comes from self._egopos
        current_location = self._ego_pos.location
        current_yaw = self._ego_pos.rotation.yaw

        # retrieve the corresponding waypoint of the current location
        current_wpt = self._map.get_waypoint(current_location).next(1)[0]
        current_wpt_loc = current_wpt.transform.location

        # retrieve the future and past waypoint to check whether a lane change is gonna operated
        future_wpt = self._waypoint_buffer[-1][0]
        previous_wpt = self._history_buffer[0][0] if len(self._history_buffer) &gt; 0 else current_wpt

        # check lateral offset from previous waypoint to current waypoint
        vec_norm, angle = cal_distance_angle(previous_wpt.transform.location,
                                             future_wpt.transform.location,
                                             future_wpt.transform.rotation.yaw)
        # distance in the lateral direction
        lateral_diff = abs(vec_norm * math.sin(math.radians(angle - 1 if angle &gt; 90 else angle + 1)))

        boundingbox = self._vehicle.bounding_box
        veh_width = 2 * abs(boundingbox.location.y - boundingbox.extent.y)
        lane_width = current_wpt.lane_width

        is_lateral_within_range = veh_width &lt; lateral_diff &lt; 2 * lane_width
        # check if the vehicle is in lane change based on lane id and lateral offset
        self.lane_id_change = (future_wpt.lane_id != current_wpt.lane_id or previous_wpt.lane_id != future_wpt.lane_id)
        self.lane_change = self.lane_id_change or is_lateral_within_range

        _, angle = cal_distance_angle(self._waypoint_buffer[0][0].transform.location, current_location, current_yaw)

        # we consider history waypoint to generate trajectory
        index = 0
        for i in range(len(self._history_buffer)):
            prev_wpt = self._history_buffer[i][0].transform.location
            _, angle = cal_distance_angle(prev_wpt, current_location, current_yaw)
            # make sure the history waypoint is already passed by
            if angle &gt; 90 and not self.lane_change:
                x.append(prev_wpt.x)
                y.append(prev_wpt.y)
                index += 1
            if self.lane_change:
                x.append(prev_wpt.x)
                y.append(prev_wpt.y)
                index += 1

        # to make sure the vehicle is stable during lane change, we don&#39;t include any current position
        if self.lane_change:
            _, angle = cal_distance_angle(self._waypoint_buffer[0][0].transform.location,
                                          current_location, current_yaw)
            print(&#39;lane change&#39;)
            # if the vehicle starts lane change at the very start
            if len(x) == 0 or len(y) == 0:
                x.append(current_location.x)
                y.append(current_location.y)
        else:
            _, angle = cal_distance_angle(current_wpt_loc, current_location, current_yaw)
            # we prefer to use waypoint as the current position for path generation if the waypoint is
            # in front of us. This is because waypoint always sits in the center
            if angle &lt; 90:
                x.append(current_wpt_loc.x)
                y.append(current_wpt_loc.y)
            else:
                x.append(current_location.x)
                y.append(current_location.y)

        # used to filter the waypoints that are too close
        prev_x = x[max(0, index - 1)] if self.lane_change else x[index]
        prev_y = y[max(0, index - 1)] if self.lane_change else y[index]
        for i in range(len(self._waypoint_buffer)):
            cur_x = self._waypoint_buffer[i][0].transform.location.x
            cur_y = self._waypoint_buffer[i][0].transform.location.y
            if abs(prev_x - cur_x) &lt; 0.5 and abs(prev_y - cur_y) &lt; 0.5:
                continue
            prev_x = cur_x
            prev_y = cur_y

            x.append(cur_x)
            y.append(cur_y)

        # Cubic Spline Interpolation calculation
        sp = Spline2D(x, y)

        diff_x = current_location.x - sp.sx.y[0]
        diff_y = current_location.y - sp.sy.y[0]
        diff_s = np.hypot(diff_x, diff_y)

        # we only need the interpolation points after current position
        s = np.arange(diff_s, sp.s[-1], ds)

        # calculate interpolation points
        rx, ry, ryaw, rk = [], [], [], []
        self._long_plan_debug = []
        # we only need the interpolation points until next waypoint
        for i_s in s:
            ix, iy = sp.calc_position(i_s)
            if abs(ix - x[index]) &lt;= ds and abs(iy - y[index]) &lt;= ds:
                continue
            self._long_plan_debug.append(carla.Transform(carla.Location(ix, iy, 0)))
            rx.append(ix)
            ry.append(iy)
            rk.append(max(min(sp.calc_curvature(i_s), 0.2), -0.2))
            ryaw.append(sp.calc_yaw(i_s))

        return rx, ry, rk, ryaw

    def generate_trajectory(self, rx, ry, rk):
        &#34;&#34;&#34;
        Sampling the generated path and assign speed to each point
        :param rx: x coordinates of planning path
        :param ry: y coordinates of planning path
        :param rk: curvature of planning path
        :param debug: whether to draw the whole plan path
        :return:
        &#34;&#34;&#34;
        # unit distance for interpolation points
        ds = 0.1
        # unit sampling resolution
        dt = self.dt

        target_speed = self._target_speed
        current_speed = self._ego_speed

        # sample the trajectory by 0.1 second
        sample_num = 2.0 // dt

        break_flag = False
        current_speed = current_speed / 3.6
        sample_resolution = 0

        # use mean curvature to constrain the speed

        mean_k = 0.0001 if len(rk) &lt; 2 else abs(statistics.mean(rk))
        # v^2 &lt;= a_lat_max / curvature, we assume 3.6 is the maximum lateral acceleration
        target_speed = min(target_speed, np.sqrt(5.0 / (mean_k + 10e-6)) * 3.6)
        print(&#39;Vehicle Id:%d, current speed %f and target speed is %f&#39; % (self._vehicle.id,
                                                                          current_speed * 3.6, target_speed))

        # TODO: This may need to be tuned more(for instance, use history speed to check acceleration)
        if self._pid_controller:
            max_acc = 3.5 if self._pid_controller.max_throttle &gt;= 0.9 else 2.5
        else:
            max_acc = 3.5
        # todo: hard-coded, need to be tuned
        acceleration = max(min(max_acc,
                               (target_speed / 3.6 - current_speed) / dt), -6.5)

        for i in range(1, int(sample_num) + 1):
            sample_resolution += current_speed * dt + 0.5 * acceleration * dt ** 2
            current_speed += acceleration * dt

            # print(sample_resolution)
            if int(sample_resolution // ds - 1) &gt;= len(rx):
                sample_x = rx[-1]
                sample_y = ry[-1]
                break_flag = True

            else:
                sample_x = rx[max(0, int(sample_resolution // ds - 1))]
                sample_y = ry[max(0, int(sample_resolution // ds - 1))]

            self._trajectory_buffer.append((carla.Transform(carla.Location(sample_x, sample_y,
                                                                           self._waypoint_buffer[0][
                                                                               0].transform.location.z + 0.5)),
                                            target_speed))
            if break_flag:
                break

    def pop_buffer(self, vehicle_transform):
        &#34;&#34;&#34;
        Remove waypoints achieved
        :return:
        &#34;&#34;&#34;
        max_index = -1

        for i, (waypoint, _) in enumerate(self._waypoint_buffer):
            if distance_vehicle(
                    waypoint, vehicle_transform) &lt; self._min_distance:
                max_index = i
        if max_index &gt;= 0:
            for i in range(max_index + 1):
                if self._history_buffer:
                    prev_wpt = self._history_buffer[-1]
                    incoming_wpt = self._waypoint_buffer.popleft()

                    if abs(prev_wpt[0].transform.location.x - incoming_wpt[0].transform.location.x) &gt; 0.5 or \
                            abs(prev_wpt[0].transform.location.y - incoming_wpt[0].transform.location.y) &gt; 0.5:
                        self._history_buffer.append(incoming_wpt)
                else:
                    self._history_buffer.append(self._waypoint_buffer.popleft())

        if self._trajectory_buffer:
            max_index = -1
            for i, (waypoint, _,) in enumerate(self._trajectory_buffer):
                if distance_vehicle(
                        waypoint, vehicle_transform) &lt; max(self._min_distance - 1, 1):
                    max_index = i
            if max_index &gt;= 0:
                for i in range(max_index + 1):
                    self._trajectory_buffer.popleft()

    def run_step(self, rx, ry, rk, target_speed=None, trajectory=None, following=False):
        &#34;&#34;&#34;
        Execute one step of local planning which involves
        running the longitudinal and lateral PID controllers to
        follow the smooth waypoints trajectory.

            :param rx: generated path x coordinates
            :param ry: generated path y coordinates
            :param rk: generated path curvatures
            :param following: whether the vehicle is under following status
            :param trajectory: pre-generated trajectory only for following vehicles in the platooning
            :param target_speed: desired speed
            :return: next trajectory point&#39;s target speed and waypoint
        &#34;&#34;&#34;

        self._target_speed = target_speed

        # Buffering the waypoints. Always keep the waypoint buffer alive todo:remove the hard coded
        if len(self._waypoint_buffer) &lt; 9:
            for i in range(self._buffer_size - len(self._waypoint_buffer)):
                if self.waypoints_queue:
                    self._waypoint_buffer.append(
                        self.waypoints_queue.popleft())
                else:
                    break

        # we will generate the trajectory only if it is not a following vehicle in the platooning
        if not trajectory and len(self._trajectory_buffer) &lt; self.trajectory_update_freq and not following:
            self._trajectory_buffer.clear()
            self.generate_trajectory(rx, ry, rk)
        elif trajectory:
            self._trajectory_buffer = trajectory.copy()

        # Target waypoint TODO: dt is never used
        self.target_waypoint, self._target_speed = \
            self._trajectory_buffer[min(1, len(self._trajectory_buffer) - 1)]

        # Purge the queue of obsolete waypoints
        vehicle_transform = self._ego_pos
        self.pop_buffer(vehicle_transform)

        if self.debug_trajectory:
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._long_plan_debug,
                                  color=carla.Color(0, 255, 0),
                                  size=0.05,
                                  lt=0.1)
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._trajectory_buffer, z=0.1, lt=0.1)

        if self.debug:
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._waypoint_buffer,
                                  z=0.1,
                                  size=0.1,
                                  color=carla.Color(0, 0, 255),
                                  lt=0.2)
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._history_buffer,
                                  z=0.1,
                                  size=0.1,
                                  color=carla.Color(255, 0, 255),
                                  lt=0.2)

        return self._target_speed, self.target_waypoint.transform.location \
            if hasattr(self.target_waypoint, &#39;is_junction&#39;) else self.target_waypoint.location</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner"><code class="flex name class">
<span>class <span class="ident">LocalPlanner</span></span>
<span>(</span><span>agent, carla_map, config_yaml)</span>
</code></dt>
<dd>
<div class="desc"><p>LocalPlanner implements the basic behavior of following a trajectory
of waypoints that is generated on-the-fly.
The low-level motion of the vehicle is computed by using two PID controllers,
one is used for the lateral control
and the other for the longitudinal control (cruise speed).</p>
<p>When multiple paths are available (intersections)
this local planner makes a random choice.</p>
<p>:param agent: agent that regulates the vehicle
:param config_yaml: local planner configuration file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalPlanner(object):
    &#34;&#34;&#34;
    LocalPlanner implements the basic behavior of following a trajectory
    of waypoints that is generated on-the-fly.
    The low-level motion of the vehicle is computed by using two PID controllers,
    one is used for the lateral control
    and the other for the longitudinal control (cruise speed).

    When multiple paths are available (intersections)
    this local planner makes a random choice.
    &#34;&#34;&#34;

    # Minimum distance to target waypoint as a percentage
    # (e.g. within 80% of total distance)

    def __init__(self, agent, carla_map, config_yaml):
        &#34;&#34;&#34;
        :param agent: agent that regulates the vehicle
        :param config_yaml: local planner configuration file
        &#34;&#34;&#34;
        self._vehicle = agent.vehicle
        self._map = carla_map

        self._ego_pos = None
        self._ego_speed = None

        # waypoint pop out thresholding
        self._min_distance = config_yaml[&#39;min_dist&#39;]
        self._buffer_size = config_yaml[&#39;buffer_size&#39;]

        # TODO: pid controller should be outside
        self._pid_controller = None

        # global route
        self.waypoints_queue = deque(maxlen=20000)
        # waypoint route
        self._waypoint_buffer = deque(maxlen=self._buffer_size)
        # trajectory buffer
        self._long_plan_debug = []
        self._trajectory_buffer = deque(maxlen=30)
        self._history_buffer = deque(maxlen=3)
        self.trajectory_update_freq = config_yaml[&#39;trajectory_update_freq&#39;]

        # trajectory sampling rate
        self.dt = config_yaml[&#39;trajectory_dt&#39;]

        # used to identify whether lane change is operated
        self.lane_change = False
        # In some corner cases, the id is not changed but we regard it as lane change due to large lateral diff
        self.lane_id_change = False

        # debug option
        self.debug = config_yaml[&#39;debug&#39;]
        self.debug_trajectory = config_yaml[&#39;debug_trajectory&#39;]

    def set_global_plan(self, current_plan, clean=False):
        &#34;&#34;&#34;
        Sets new global plan.

            :param clean:
            :param current_plan: list of waypoints in the actual plan
        &#34;&#34;&#34;
        for elem in current_plan:
            self.waypoints_queue.append(elem)

        if clean:
            self._waypoint_buffer.clear()
            for _ in range(self._buffer_size):
                if self.waypoints_queue:
                    self._waypoint_buffer.append(
                        self.waypoints_queue.popleft())
                else:
                    break

    def update_information(self, ego_pos, ego_speed):
        &#34;&#34;&#34;
        Update the ego position and speed for trajectory planner.
        Args:
            ego_pos (carla.Transform): Ego position from localization module.
            ego_speed (float): Ego speed(km/h) from localization module.

        Returns:

        &#34;&#34;&#34;
        self._ego_pos = ego_pos
        self._ego_speed = ego_speed

    def get_trajetory(self):
        &#34;&#34;&#34;
        Get the trajetory
        :return:
        &#34;&#34;&#34;
        return self._trajectory_buffer

    def generate_path(self):
        &#34;&#34;&#34;
        Generate the smooth path using cubic spline
        :return: rx, ry, ryaw, rk: list of planned path points&#39; x,y coordinates, yaw angle and curvature
        &#34;&#34;&#34;

        # used to save all key spline node
        x = []
        y = []

        # [m] distance of each interpolated points
        ds = 0.1

        # retrieve current location, yaw angle todo: this should comes from self._egopos
        current_location = self._ego_pos.location
        current_yaw = self._ego_pos.rotation.yaw

        # retrieve the corresponding waypoint of the current location
        current_wpt = self._map.get_waypoint(current_location).next(1)[0]
        current_wpt_loc = current_wpt.transform.location

        # retrieve the future and past waypoint to check whether a lane change is gonna operated
        future_wpt = self._waypoint_buffer[-1][0]
        previous_wpt = self._history_buffer[0][0] if len(self._history_buffer) &gt; 0 else current_wpt

        # check lateral offset from previous waypoint to current waypoint
        vec_norm, angle = cal_distance_angle(previous_wpt.transform.location,
                                             future_wpt.transform.location,
                                             future_wpt.transform.rotation.yaw)
        # distance in the lateral direction
        lateral_diff = abs(vec_norm * math.sin(math.radians(angle - 1 if angle &gt; 90 else angle + 1)))

        boundingbox = self._vehicle.bounding_box
        veh_width = 2 * abs(boundingbox.location.y - boundingbox.extent.y)
        lane_width = current_wpt.lane_width

        is_lateral_within_range = veh_width &lt; lateral_diff &lt; 2 * lane_width
        # check if the vehicle is in lane change based on lane id and lateral offset
        self.lane_id_change = (future_wpt.lane_id != current_wpt.lane_id or previous_wpt.lane_id != future_wpt.lane_id)
        self.lane_change = self.lane_id_change or is_lateral_within_range

        _, angle = cal_distance_angle(self._waypoint_buffer[0][0].transform.location, current_location, current_yaw)

        # we consider history waypoint to generate trajectory
        index = 0
        for i in range(len(self._history_buffer)):
            prev_wpt = self._history_buffer[i][0].transform.location
            _, angle = cal_distance_angle(prev_wpt, current_location, current_yaw)
            # make sure the history waypoint is already passed by
            if angle &gt; 90 and not self.lane_change:
                x.append(prev_wpt.x)
                y.append(prev_wpt.y)
                index += 1
            if self.lane_change:
                x.append(prev_wpt.x)
                y.append(prev_wpt.y)
                index += 1

        # to make sure the vehicle is stable during lane change, we don&#39;t include any current position
        if self.lane_change:
            _, angle = cal_distance_angle(self._waypoint_buffer[0][0].transform.location,
                                          current_location, current_yaw)
            print(&#39;lane change&#39;)
            # if the vehicle starts lane change at the very start
            if len(x) == 0 or len(y) == 0:
                x.append(current_location.x)
                y.append(current_location.y)
        else:
            _, angle = cal_distance_angle(current_wpt_loc, current_location, current_yaw)
            # we prefer to use waypoint as the current position for path generation if the waypoint is
            # in front of us. This is because waypoint always sits in the center
            if angle &lt; 90:
                x.append(current_wpt_loc.x)
                y.append(current_wpt_loc.y)
            else:
                x.append(current_location.x)
                y.append(current_location.y)

        # used to filter the waypoints that are too close
        prev_x = x[max(0, index - 1)] if self.lane_change else x[index]
        prev_y = y[max(0, index - 1)] if self.lane_change else y[index]
        for i in range(len(self._waypoint_buffer)):
            cur_x = self._waypoint_buffer[i][0].transform.location.x
            cur_y = self._waypoint_buffer[i][0].transform.location.y
            if abs(prev_x - cur_x) &lt; 0.5 and abs(prev_y - cur_y) &lt; 0.5:
                continue
            prev_x = cur_x
            prev_y = cur_y

            x.append(cur_x)
            y.append(cur_y)

        # Cubic Spline Interpolation calculation
        sp = Spline2D(x, y)

        diff_x = current_location.x - sp.sx.y[0]
        diff_y = current_location.y - sp.sy.y[0]
        diff_s = np.hypot(diff_x, diff_y)

        # we only need the interpolation points after current position
        s = np.arange(diff_s, sp.s[-1], ds)

        # calculate interpolation points
        rx, ry, ryaw, rk = [], [], [], []
        self._long_plan_debug = []
        # we only need the interpolation points until next waypoint
        for i_s in s:
            ix, iy = sp.calc_position(i_s)
            if abs(ix - x[index]) &lt;= ds and abs(iy - y[index]) &lt;= ds:
                continue
            self._long_plan_debug.append(carla.Transform(carla.Location(ix, iy, 0)))
            rx.append(ix)
            ry.append(iy)
            rk.append(max(min(sp.calc_curvature(i_s), 0.2), -0.2))
            ryaw.append(sp.calc_yaw(i_s))

        return rx, ry, rk, ryaw

    def generate_trajectory(self, rx, ry, rk):
        &#34;&#34;&#34;
        Sampling the generated path and assign speed to each point
        :param rx: x coordinates of planning path
        :param ry: y coordinates of planning path
        :param rk: curvature of planning path
        :param debug: whether to draw the whole plan path
        :return:
        &#34;&#34;&#34;
        # unit distance for interpolation points
        ds = 0.1
        # unit sampling resolution
        dt = self.dt

        target_speed = self._target_speed
        current_speed = self._ego_speed

        # sample the trajectory by 0.1 second
        sample_num = 2.0 // dt

        break_flag = False
        current_speed = current_speed / 3.6
        sample_resolution = 0

        # use mean curvature to constrain the speed

        mean_k = 0.0001 if len(rk) &lt; 2 else abs(statistics.mean(rk))
        # v^2 &lt;= a_lat_max / curvature, we assume 3.6 is the maximum lateral acceleration
        target_speed = min(target_speed, np.sqrt(5.0 / (mean_k + 10e-6)) * 3.6)
        print(&#39;Vehicle Id:%d, current speed %f and target speed is %f&#39; % (self._vehicle.id,
                                                                          current_speed * 3.6, target_speed))

        # TODO: This may need to be tuned more(for instance, use history speed to check acceleration)
        if self._pid_controller:
            max_acc = 3.5 if self._pid_controller.max_throttle &gt;= 0.9 else 2.5
        else:
            max_acc = 3.5
        # todo: hard-coded, need to be tuned
        acceleration = max(min(max_acc,
                               (target_speed / 3.6 - current_speed) / dt), -6.5)

        for i in range(1, int(sample_num) + 1):
            sample_resolution += current_speed * dt + 0.5 * acceleration * dt ** 2
            current_speed += acceleration * dt

            # print(sample_resolution)
            if int(sample_resolution // ds - 1) &gt;= len(rx):
                sample_x = rx[-1]
                sample_y = ry[-1]
                break_flag = True

            else:
                sample_x = rx[max(0, int(sample_resolution // ds - 1))]
                sample_y = ry[max(0, int(sample_resolution // ds - 1))]

            self._trajectory_buffer.append((carla.Transform(carla.Location(sample_x, sample_y,
                                                                           self._waypoint_buffer[0][
                                                                               0].transform.location.z + 0.5)),
                                            target_speed))
            if break_flag:
                break

    def pop_buffer(self, vehicle_transform):
        &#34;&#34;&#34;
        Remove waypoints achieved
        :return:
        &#34;&#34;&#34;
        max_index = -1

        for i, (waypoint, _) in enumerate(self._waypoint_buffer):
            if distance_vehicle(
                    waypoint, vehicle_transform) &lt; self._min_distance:
                max_index = i
        if max_index &gt;= 0:
            for i in range(max_index + 1):
                if self._history_buffer:
                    prev_wpt = self._history_buffer[-1]
                    incoming_wpt = self._waypoint_buffer.popleft()

                    if abs(prev_wpt[0].transform.location.x - incoming_wpt[0].transform.location.x) &gt; 0.5 or \
                            abs(prev_wpt[0].transform.location.y - incoming_wpt[0].transform.location.y) &gt; 0.5:
                        self._history_buffer.append(incoming_wpt)
                else:
                    self._history_buffer.append(self._waypoint_buffer.popleft())

        if self._trajectory_buffer:
            max_index = -1
            for i, (waypoint, _,) in enumerate(self._trajectory_buffer):
                if distance_vehicle(
                        waypoint, vehicle_transform) &lt; max(self._min_distance - 1, 1):
                    max_index = i
            if max_index &gt;= 0:
                for i in range(max_index + 1):
                    self._trajectory_buffer.popleft()

    def run_step(self, rx, ry, rk, target_speed=None, trajectory=None, following=False):
        &#34;&#34;&#34;
        Execute one step of local planning which involves
        running the longitudinal and lateral PID controllers to
        follow the smooth waypoints trajectory.

            :param rx: generated path x coordinates
            :param ry: generated path y coordinates
            :param rk: generated path curvatures
            :param following: whether the vehicle is under following status
            :param trajectory: pre-generated trajectory only for following vehicles in the platooning
            :param target_speed: desired speed
            :return: next trajectory point&#39;s target speed and waypoint
        &#34;&#34;&#34;

        self._target_speed = target_speed

        # Buffering the waypoints. Always keep the waypoint buffer alive todo:remove the hard coded
        if len(self._waypoint_buffer) &lt; 9:
            for i in range(self._buffer_size - len(self._waypoint_buffer)):
                if self.waypoints_queue:
                    self._waypoint_buffer.append(
                        self.waypoints_queue.popleft())
                else:
                    break

        # we will generate the trajectory only if it is not a following vehicle in the platooning
        if not trajectory and len(self._trajectory_buffer) &lt; self.trajectory_update_freq and not following:
            self._trajectory_buffer.clear()
            self.generate_trajectory(rx, ry, rk)
        elif trajectory:
            self._trajectory_buffer = trajectory.copy()

        # Target waypoint TODO: dt is never used
        self.target_waypoint, self._target_speed = \
            self._trajectory_buffer[min(1, len(self._trajectory_buffer) - 1)]

        # Purge the queue of obsolete waypoints
        vehicle_transform = self._ego_pos
        self.pop_buffer(vehicle_transform)

        if self.debug_trajectory:
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._long_plan_debug,
                                  color=carla.Color(0, 255, 0),
                                  size=0.05,
                                  lt=0.1)
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._trajectory_buffer, z=0.1, lt=0.1)

        if self.debug:
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._waypoint_buffer,
                                  z=0.1,
                                  size=0.1,
                                  color=carla.Color(0, 0, 255),
                                  lt=0.2)
            draw_trajetory_points(self._vehicle.get_world(),
                                  self._history_buffer,
                                  z=0.1,
                                  size=0.1,
                                  color=carla.Color(255, 0, 255),
                                  lt=0.2)

        return self._target_speed, self.target_waypoint.transform.location \
            if hasattr(self.target_waypoint, &#39;is_junction&#39;) else self.target_waypoint.location</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.generate_path"><code class="name flex">
<span>def <span class="ident">generate_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the smooth path using cubic spline
:return: rx, ry, ryaw, rk: list of planned path points' x,y coordinates, yaw angle and curvature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_path(self):
    &#34;&#34;&#34;
    Generate the smooth path using cubic spline
    :return: rx, ry, ryaw, rk: list of planned path points&#39; x,y coordinates, yaw angle and curvature
    &#34;&#34;&#34;

    # used to save all key spline node
    x = []
    y = []

    # [m] distance of each interpolated points
    ds = 0.1

    # retrieve current location, yaw angle todo: this should comes from self._egopos
    current_location = self._ego_pos.location
    current_yaw = self._ego_pos.rotation.yaw

    # retrieve the corresponding waypoint of the current location
    current_wpt = self._map.get_waypoint(current_location).next(1)[0]
    current_wpt_loc = current_wpt.transform.location

    # retrieve the future and past waypoint to check whether a lane change is gonna operated
    future_wpt = self._waypoint_buffer[-1][0]
    previous_wpt = self._history_buffer[0][0] if len(self._history_buffer) &gt; 0 else current_wpt

    # check lateral offset from previous waypoint to current waypoint
    vec_norm, angle = cal_distance_angle(previous_wpt.transform.location,
                                         future_wpt.transform.location,
                                         future_wpt.transform.rotation.yaw)
    # distance in the lateral direction
    lateral_diff = abs(vec_norm * math.sin(math.radians(angle - 1 if angle &gt; 90 else angle + 1)))

    boundingbox = self._vehicle.bounding_box
    veh_width = 2 * abs(boundingbox.location.y - boundingbox.extent.y)
    lane_width = current_wpt.lane_width

    is_lateral_within_range = veh_width &lt; lateral_diff &lt; 2 * lane_width
    # check if the vehicle is in lane change based on lane id and lateral offset
    self.lane_id_change = (future_wpt.lane_id != current_wpt.lane_id or previous_wpt.lane_id != future_wpt.lane_id)
    self.lane_change = self.lane_id_change or is_lateral_within_range

    _, angle = cal_distance_angle(self._waypoint_buffer[0][0].transform.location, current_location, current_yaw)

    # we consider history waypoint to generate trajectory
    index = 0
    for i in range(len(self._history_buffer)):
        prev_wpt = self._history_buffer[i][0].transform.location
        _, angle = cal_distance_angle(prev_wpt, current_location, current_yaw)
        # make sure the history waypoint is already passed by
        if angle &gt; 90 and not self.lane_change:
            x.append(prev_wpt.x)
            y.append(prev_wpt.y)
            index += 1
        if self.lane_change:
            x.append(prev_wpt.x)
            y.append(prev_wpt.y)
            index += 1

    # to make sure the vehicle is stable during lane change, we don&#39;t include any current position
    if self.lane_change:
        _, angle = cal_distance_angle(self._waypoint_buffer[0][0].transform.location,
                                      current_location, current_yaw)
        print(&#39;lane change&#39;)
        # if the vehicle starts lane change at the very start
        if len(x) == 0 or len(y) == 0:
            x.append(current_location.x)
            y.append(current_location.y)
    else:
        _, angle = cal_distance_angle(current_wpt_loc, current_location, current_yaw)
        # we prefer to use waypoint as the current position for path generation if the waypoint is
        # in front of us. This is because waypoint always sits in the center
        if angle &lt; 90:
            x.append(current_wpt_loc.x)
            y.append(current_wpt_loc.y)
        else:
            x.append(current_location.x)
            y.append(current_location.y)

    # used to filter the waypoints that are too close
    prev_x = x[max(0, index - 1)] if self.lane_change else x[index]
    prev_y = y[max(0, index - 1)] if self.lane_change else y[index]
    for i in range(len(self._waypoint_buffer)):
        cur_x = self._waypoint_buffer[i][0].transform.location.x
        cur_y = self._waypoint_buffer[i][0].transform.location.y
        if abs(prev_x - cur_x) &lt; 0.5 and abs(prev_y - cur_y) &lt; 0.5:
            continue
        prev_x = cur_x
        prev_y = cur_y

        x.append(cur_x)
        y.append(cur_y)

    # Cubic Spline Interpolation calculation
    sp = Spline2D(x, y)

    diff_x = current_location.x - sp.sx.y[0]
    diff_y = current_location.y - sp.sy.y[0]
    diff_s = np.hypot(diff_x, diff_y)

    # we only need the interpolation points after current position
    s = np.arange(diff_s, sp.s[-1], ds)

    # calculate interpolation points
    rx, ry, ryaw, rk = [], [], [], []
    self._long_plan_debug = []
    # we only need the interpolation points until next waypoint
    for i_s in s:
        ix, iy = sp.calc_position(i_s)
        if abs(ix - x[index]) &lt;= ds and abs(iy - y[index]) &lt;= ds:
            continue
        self._long_plan_debug.append(carla.Transform(carla.Location(ix, iy, 0)))
        rx.append(ix)
        ry.append(iy)
        rk.append(max(min(sp.calc_curvature(i_s), 0.2), -0.2))
        ryaw.append(sp.calc_yaw(i_s))

    return rx, ry, rk, ryaw</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.generate_trajectory"><code class="name flex">
<span>def <span class="ident">generate_trajectory</span></span>(<span>self, rx, ry, rk)</span>
</code></dt>
<dd>
<div class="desc"><p>Sampling the generated path and assign speed to each point
:param rx: x coordinates of planning path
:param ry: y coordinates of planning path
:param rk: curvature of planning path
:param debug: whether to draw the whole plan path
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_trajectory(self, rx, ry, rk):
    &#34;&#34;&#34;
    Sampling the generated path and assign speed to each point
    :param rx: x coordinates of planning path
    :param ry: y coordinates of planning path
    :param rk: curvature of planning path
    :param debug: whether to draw the whole plan path
    :return:
    &#34;&#34;&#34;
    # unit distance for interpolation points
    ds = 0.1
    # unit sampling resolution
    dt = self.dt

    target_speed = self._target_speed
    current_speed = self._ego_speed

    # sample the trajectory by 0.1 second
    sample_num = 2.0 // dt

    break_flag = False
    current_speed = current_speed / 3.6
    sample_resolution = 0

    # use mean curvature to constrain the speed

    mean_k = 0.0001 if len(rk) &lt; 2 else abs(statistics.mean(rk))
    # v^2 &lt;= a_lat_max / curvature, we assume 3.6 is the maximum lateral acceleration
    target_speed = min(target_speed, np.sqrt(5.0 / (mean_k + 10e-6)) * 3.6)
    print(&#39;Vehicle Id:%d, current speed %f and target speed is %f&#39; % (self._vehicle.id,
                                                                      current_speed * 3.6, target_speed))

    # TODO: This may need to be tuned more(for instance, use history speed to check acceleration)
    if self._pid_controller:
        max_acc = 3.5 if self._pid_controller.max_throttle &gt;= 0.9 else 2.5
    else:
        max_acc = 3.5
    # todo: hard-coded, need to be tuned
    acceleration = max(min(max_acc,
                           (target_speed / 3.6 - current_speed) / dt), -6.5)

    for i in range(1, int(sample_num) + 1):
        sample_resolution += current_speed * dt + 0.5 * acceleration * dt ** 2
        current_speed += acceleration * dt

        # print(sample_resolution)
        if int(sample_resolution // ds - 1) &gt;= len(rx):
            sample_x = rx[-1]
            sample_y = ry[-1]
            break_flag = True

        else:
            sample_x = rx[max(0, int(sample_resolution // ds - 1))]
            sample_y = ry[max(0, int(sample_resolution // ds - 1))]

        self._trajectory_buffer.append((carla.Transform(carla.Location(sample_x, sample_y,
                                                                       self._waypoint_buffer[0][
                                                                           0].transform.location.z + 0.5)),
                                        target_speed))
        if break_flag:
            break</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.get_trajetory"><code class="name flex">
<span>def <span class="ident">get_trajetory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the trajetory
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trajetory(self):
    &#34;&#34;&#34;
    Get the trajetory
    :return:
    &#34;&#34;&#34;
    return self._trajectory_buffer</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.pop_buffer"><code class="name flex">
<span>def <span class="ident">pop_buffer</span></span>(<span>self, vehicle_transform)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove waypoints achieved
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_buffer(self, vehicle_transform):
    &#34;&#34;&#34;
    Remove waypoints achieved
    :return:
    &#34;&#34;&#34;
    max_index = -1

    for i, (waypoint, _) in enumerate(self._waypoint_buffer):
        if distance_vehicle(
                waypoint, vehicle_transform) &lt; self._min_distance:
            max_index = i
    if max_index &gt;= 0:
        for i in range(max_index + 1):
            if self._history_buffer:
                prev_wpt = self._history_buffer[-1]
                incoming_wpt = self._waypoint_buffer.popleft()

                if abs(prev_wpt[0].transform.location.x - incoming_wpt[0].transform.location.x) &gt; 0.5 or \
                        abs(prev_wpt[0].transform.location.y - incoming_wpt[0].transform.location.y) &gt; 0.5:
                    self._history_buffer.append(incoming_wpt)
            else:
                self._history_buffer.append(self._waypoint_buffer.popleft())

    if self._trajectory_buffer:
        max_index = -1
        for i, (waypoint, _,) in enumerate(self._trajectory_buffer):
            if distance_vehicle(
                    waypoint, vehicle_transform) &lt; max(self._min_distance - 1, 1):
                max_index = i
        if max_index &gt;= 0:
            for i in range(max_index + 1):
                self._trajectory_buffer.popleft()</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.run_step"><code class="name flex">
<span>def <span class="ident">run_step</span></span>(<span>self, rx, ry, rk, target_speed=None, trajectory=None, following=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute one step of local planning which involves
running the longitudinal and lateral PID controllers to
follow the smooth waypoints trajectory.</p>
<pre><code>:param rx: generated path x coordinates
:param ry: generated path y coordinates
:param rk: generated path curvatures
:param following: whether the vehicle is under following status
:param trajectory: pre-generated trajectory only for following vehicles in the platooning
:param target_speed: desired speed
:return: next trajectory point's target speed and waypoint
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step(self, rx, ry, rk, target_speed=None, trajectory=None, following=False):
    &#34;&#34;&#34;
    Execute one step of local planning which involves
    running the longitudinal and lateral PID controllers to
    follow the smooth waypoints trajectory.

        :param rx: generated path x coordinates
        :param ry: generated path y coordinates
        :param rk: generated path curvatures
        :param following: whether the vehicle is under following status
        :param trajectory: pre-generated trajectory only for following vehicles in the platooning
        :param target_speed: desired speed
        :return: next trajectory point&#39;s target speed and waypoint
    &#34;&#34;&#34;

    self._target_speed = target_speed

    # Buffering the waypoints. Always keep the waypoint buffer alive todo:remove the hard coded
    if len(self._waypoint_buffer) &lt; 9:
        for i in range(self._buffer_size - len(self._waypoint_buffer)):
            if self.waypoints_queue:
                self._waypoint_buffer.append(
                    self.waypoints_queue.popleft())
            else:
                break

    # we will generate the trajectory only if it is not a following vehicle in the platooning
    if not trajectory and len(self._trajectory_buffer) &lt; self.trajectory_update_freq and not following:
        self._trajectory_buffer.clear()
        self.generate_trajectory(rx, ry, rk)
    elif trajectory:
        self._trajectory_buffer = trajectory.copy()

    # Target waypoint TODO: dt is never used
    self.target_waypoint, self._target_speed = \
        self._trajectory_buffer[min(1, len(self._trajectory_buffer) - 1)]

    # Purge the queue of obsolete waypoints
    vehicle_transform = self._ego_pos
    self.pop_buffer(vehicle_transform)

    if self.debug_trajectory:
        draw_trajetory_points(self._vehicle.get_world(),
                              self._long_plan_debug,
                              color=carla.Color(0, 255, 0),
                              size=0.05,
                              lt=0.1)
        draw_trajetory_points(self._vehicle.get_world(),
                              self._trajectory_buffer, z=0.1, lt=0.1)

    if self.debug:
        draw_trajetory_points(self._vehicle.get_world(),
                              self._waypoint_buffer,
                              z=0.1,
                              size=0.1,
                              color=carla.Color(0, 0, 255),
                              lt=0.2)
        draw_trajetory_points(self._vehicle.get_world(),
                              self._history_buffer,
                              z=0.1,
                              size=0.1,
                              color=carla.Color(255, 0, 255),
                              lt=0.2)

    return self._target_speed, self.target_waypoint.transform.location \
        if hasattr(self.target_waypoint, &#39;is_junction&#39;) else self.target_waypoint.location</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.set_global_plan"><code class="name flex">
<span>def <span class="ident">set_global_plan</span></span>(<span>self, current_plan, clean=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets new global plan.</p>
<pre><code>:param clean:
:param current_plan: list of waypoints in the actual plan
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_global_plan(self, current_plan, clean=False):
    &#34;&#34;&#34;
    Sets new global plan.

        :param clean:
        :param current_plan: list of waypoints in the actual plan
    &#34;&#34;&#34;
    for elem in current_plan:
        self.waypoints_queue.append(elem)

    if clean:
        self._waypoint_buffer.clear()
        for _ in range(self._buffer_size):
            if self.waypoints_queue:
                self._waypoint_buffer.append(
                    self.waypoints_queue.popleft())
            else:
                break</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.LocalPlanner.update_information"><code class="name flex">
<span>def <span class="ident">update_information</span></span>(<span>self, ego_pos, ego_speed)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the ego position and speed for trajectory planner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ego_pos</code></strong> :&ensp;<code>carla.Transform</code></dt>
<dd>Ego position from localization module.</dd>
<dt><strong><code>ego_speed</code></strong> :&ensp;<code>float</code></dt>
<dd>Ego speed(km/h) from localization module.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_information(self, ego_pos, ego_speed):
    &#34;&#34;&#34;
    Update the ego position and speed for trajectory planner.
    Args:
        ego_pos (carla.Transform): Ego position from localization module.
        ego_speed (float): Ego speed(km/h) from localization module.

    Returns:

    &#34;&#34;&#34;
    self._ego_pos = ego_pos
    self._ego_speed = ego_speed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption"><code class="flex name class">
<span>class <span class="ident">RoadOption</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>RoadOption represents the possible topological configurations
when moving from a segment of lane to other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadOption(Enum):
    &#34;&#34;&#34;
    RoadOption represents the possible topological configurations
    when moving from a segment of lane to other.
    &#34;&#34;&#34;
    VOID = -1
    LEFT = 1
    RIGHT = 2
    STRAIGHT = 3
    LANEFOLLOW = 4
    CHANGELANELEFT = 5
    CHANGELANERIGHT = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.CHANGELANELEFT"><code class="name">var <span class="ident">CHANGELANELEFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.CHANGELANERIGHT"><code class="name">var <span class="ident">CHANGELANERIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.LANEFOLLOW"><code class="name">var <span class="ident">LANEFOLLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.LEFT"><code class="name">var <span class="ident">LEFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.RIGHT"><code class="name">var <span class="ident">RIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.STRAIGHT"><code class="name">var <span class="ident">STRAIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opencda.core.plan.local_planner_behavior.RoadOption.VOID"><code class="name">var <span class="ident">VOID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opencda.core.plan" href="index.html">opencda.core.plan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner" href="#opencda.core.plan.local_planner_behavior.LocalPlanner">LocalPlanner</a></code></h4>
<ul class="two-column">
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.generate_path" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.generate_path">generate_path</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.generate_trajectory" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.generate_trajectory">generate_trajectory</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.get_trajetory" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.get_trajetory">get_trajetory</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.pop_buffer" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.pop_buffer">pop_buffer</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.run_step" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.run_step">run_step</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.set_global_plan" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.set_global_plan">set_global_plan</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.LocalPlanner.update_information" href="#opencda.core.plan.local_planner_behavior.LocalPlanner.update_information">update_information</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opencda.core.plan.local_planner_behavior.RoadOption" href="#opencda.core.plan.local_planner_behavior.RoadOption">RoadOption</a></code></h4>
<ul class="two-column">
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.CHANGELANELEFT" href="#opencda.core.plan.local_planner_behavior.RoadOption.CHANGELANELEFT">CHANGELANELEFT</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.CHANGELANERIGHT" href="#opencda.core.plan.local_planner_behavior.RoadOption.CHANGELANERIGHT">CHANGELANERIGHT</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.LANEFOLLOW" href="#opencda.core.plan.local_planner_behavior.RoadOption.LANEFOLLOW">LANEFOLLOW</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.LEFT" href="#opencda.core.plan.local_planner_behavior.RoadOption.LEFT">LEFT</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.RIGHT" href="#opencda.core.plan.local_planner_behavior.RoadOption.RIGHT">RIGHT</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.STRAIGHT" href="#opencda.core.plan.local_planner_behavior.RoadOption.STRAIGHT">STRAIGHT</a></code></li>
<li><code><a title="opencda.core.plan.local_planner_behavior.RoadOption.VOID" href="#opencda.core.plan.local_planner_behavior.RoadOption.VOID">VOID</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
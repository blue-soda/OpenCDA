<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>opencda.core.plan.spline API documentation</title>
<meta name="description" content="Cubic spline planner â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>opencda.core.plan.spline</code></h1>
</header>
<section id="section-intro">
<p>Cubic spline planner</p>
<p>Author: Atsushi Sakai(@Atsushi_twi)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Cubic spline planner

Author: Atsushi Sakai(@Atsushi_twi)

&#34;&#34;&#34;
import math
import numpy as np
import bisect


class Spline:
    &#34;&#34;&#34;
    Cubic Spline class
    &#34;&#34;&#34;

    def __init__(self, x, y):
        self.b, self.c, self.d, self.w = [], [], [], []

        self.x = x
        self.y = y

        self.nx = len(x)  # dimension of x
        h = np.diff(x)

        # calc coefficient c
        self.a = [iy for iy in y]

        # calc coefficient c
        A = self.__calc_A(h)
        B = self.__calc_B(h)
        self.c = np.linalg.solve(A, B)
        #  print(self.c1)

        # calc spline coefficient b and d
        for i in range(self.nx - 1):
            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))
            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \
                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0
            self.b.append(tb)

    def calc(self, t):
        &#34;&#34;&#34;
        Calc position

        if t is outside of the input x, return None

        &#34;&#34;&#34;

        if t &lt; self.x[0]:
            return None
        elif t &gt; self.x[-1]:
            return None

        i = self.__search_index(t)
        dx = t - self.x[i]
        result = self.a[i] + self.b[i] * dx + \
            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0

        return result

    def calcd(self, t):
        &#34;&#34;&#34;
        Calc first derivative

        if t is outside of the input x, return None
        &#34;&#34;&#34;

        if t &lt; self.x[0]:
            return None
        elif t &gt; self.x[-1]:
            return None

        i = self.__search_index(t)
        dx = t - self.x[i]
        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0
        return result

    def calcdd(self, t):
        &#34;&#34;&#34;
        Calc second derivative
        &#34;&#34;&#34;

        if t &lt; self.x[0]:
            return None
        elif t &gt; self.x[-1]:
            return None

        i = self.__search_index(t)
        dx = t - self.x[i]
        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx
        return result

    def __search_index(self, x):
        &#34;&#34;&#34;
        search data segment index
        &#34;&#34;&#34;
        return bisect.bisect(self.x, x) - 1

    def __calc_A(self, h):
        &#34;&#34;&#34;
        calc matrix A for spline coefficient c
        &#34;&#34;&#34;
        A = np.zeros((self.nx, self.nx))
        A[0, 0] = 1.0
        for i in range(self.nx - 1):
            if i != (self.nx - 2):
                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])
            A[i + 1, i] = h[i]
            A[i, i + 1] = h[i]

        A[0, 1] = 0.0
        A[self.nx - 1, self.nx - 2] = 0.0
        A[self.nx - 1, self.nx - 1] = 1.0
        #  print(A)
        return A

    def __calc_B(self, h):
        &#34;&#34;&#34;
        calc matrix B for spline coefficient c
        &#34;&#34;&#34;
        B = np.zeros(self.nx)
        for i in range(self.nx - 2):
            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \
                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]
        return B


class Spline2D:
    &#34;&#34;&#34;
    2D Cubic Spline class

    &#34;&#34;&#34;

    def __init__(self, x, y):
        self.s = self.__calc_s(x, y)
        self.sx = Spline(self.s, x)
        self.sy = Spline(self.s, y)

    def __calc_s(self, x, y):
        dx = np.diff(x)
        dy = np.diff(y)
        self.ds = np.hypot(dx, dy)
        s = [0]
        s.extend(np.cumsum(self.ds))
        return s

    def calc_position(self, s):
        &#34;&#34;&#34;
        calc position
        &#34;&#34;&#34;
        x = self.sx.calc(s)
        y = self.sy.calc(s)

        return x, y

    def calc_curvature(self, s):
        &#34;&#34;&#34;
        calc curvature
        &#34;&#34;&#34;
        dx = self.sx.calcd(s)
        ddx = self.sx.calcdd(s)
        dy = self.sy.calcd(s)
        ddy = self.sy.calcdd(s)
        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))
        return k

    def calc_yaw(self, s):
        &#34;&#34;&#34;
        calc yaw
        &#34;&#34;&#34;
        dx = self.sx.calcd(s)
        dy = self.sy.calcd(s)
        yaw = math.atan2(dy, dx)
        return yaw


def calc_spline_course(x, y, ds=0.1):
    sp = Spline2D(x, y)
    s = list(np.arange(0, sp.s[-1], ds))

    rx, ry, ryaw, rk = [], [], [], []
    for i_s in s:
        ix, iy = sp.calc_position(i_s)
        rx.append(ix)
        ry.append(iy)
        ryaw.append(sp.calc_yaw(i_s))
        rk.append(sp.calc_curvature(i_s))

    return rx, ry, ryaw, rk, s


def main():  # pragma: no cover
    print(&#34;Spline 2D test&#34;)
    import matplotlib.pyplot as plt
    x = [-135, -131, -131, -131]
    y = [6.43, 10.83, 100.38, 131]
    ds = 0.1  # [m] distance of each intepolated points

    sp = Spline2D(x, y)
    s = np.arange(0, sp.s[-1], ds)

    rx, ry, ryaw, rk = [], [], [], []
    for i_s in s:
        ix, iy = sp.calc_position(i_s)
        rx.append(ix)
        ry.append(iy)
        ryaw.append(sp.calc_yaw(i_s))
        rk.append(sp.calc_curvature(i_s))

    plt.subplots(1)
    plt.plot(x, y, &#34;xb&#34;, label=&#34;input&#34;)
    plt.plot(rx, ry, &#34;-r&#34;, label=&#34;spline&#34;)
    plt.grid(True)
    plt.axis(&#34;equal&#34;)
    plt.xlabel(&#34;x[m]&#34;)
    plt.ylabel(&#34;y[m]&#34;)
    plt.legend()

    plt.subplots(1)
    plt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], &#34;-r&#34;, label=&#34;yaw&#34;)
    plt.grid(True)
    plt.legend()
    plt.xlabel(&#34;line length[m]&#34;)
    plt.ylabel(&#34;yaw angle[deg]&#34;)

    plt.subplots(1)
    plt.plot(s, rk, &#34;-r&#34;, label=&#34;curvature&#34;)
    plt.grid(True)
    plt.legend()
    plt.xlabel(&#34;line length[m]&#34;)
    plt.ylabel(&#34;curvature [1/m]&#34;)

    plt.show()


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opencda.core.plan.spline.calc_spline_course"><code class="name flex">
<span>def <span class="ident">calc_spline_course</span></span>(<span>x, y, ds=0.1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_spline_course(x, y, ds=0.1):
    sp = Spline2D(x, y)
    s = list(np.arange(0, sp.s[-1], ds))

    rx, ry, ryaw, rk = [], [], [], []
    for i_s in s:
        ix, iy = sp.calc_position(i_s)
        rx.append(ix)
        ry.append(iy)
        ryaw.append(sp.calc_yaw(i_s))
        rk.append(sp.calc_curvature(i_s))

    return rx, ry, ryaw, rk, s</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.spline.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():  # pragma: no cover
    print(&#34;Spline 2D test&#34;)
    import matplotlib.pyplot as plt
    x = [-135, -131, -131, -131]
    y = [6.43, 10.83, 100.38, 131]
    ds = 0.1  # [m] distance of each intepolated points

    sp = Spline2D(x, y)
    s = np.arange(0, sp.s[-1], ds)

    rx, ry, ryaw, rk = [], [], [], []
    for i_s in s:
        ix, iy = sp.calc_position(i_s)
        rx.append(ix)
        ry.append(iy)
        ryaw.append(sp.calc_yaw(i_s))
        rk.append(sp.calc_curvature(i_s))

    plt.subplots(1)
    plt.plot(x, y, &#34;xb&#34;, label=&#34;input&#34;)
    plt.plot(rx, ry, &#34;-r&#34;, label=&#34;spline&#34;)
    plt.grid(True)
    plt.axis(&#34;equal&#34;)
    plt.xlabel(&#34;x[m]&#34;)
    plt.ylabel(&#34;y[m]&#34;)
    plt.legend()

    plt.subplots(1)
    plt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], &#34;-r&#34;, label=&#34;yaw&#34;)
    plt.grid(True)
    plt.legend()
    plt.xlabel(&#34;line length[m]&#34;)
    plt.ylabel(&#34;yaw angle[deg]&#34;)

    plt.subplots(1)
    plt.plot(s, rk, &#34;-r&#34;, label=&#34;curvature&#34;)
    plt.grid(True)
    plt.legend()
    plt.xlabel(&#34;line length[m]&#34;)
    plt.ylabel(&#34;curvature [1/m]&#34;)

    plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opencda.core.plan.spline.Spline"><code class="flex name class">
<span>class <span class="ident">Spline</span></span>
<span>(</span><span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Cubic Spline class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spline:
    &#34;&#34;&#34;
    Cubic Spline class
    &#34;&#34;&#34;

    def __init__(self, x, y):
        self.b, self.c, self.d, self.w = [], [], [], []

        self.x = x
        self.y = y

        self.nx = len(x)  # dimension of x
        h = np.diff(x)

        # calc coefficient c
        self.a = [iy for iy in y]

        # calc coefficient c
        A = self.__calc_A(h)
        B = self.__calc_B(h)
        self.c = np.linalg.solve(A, B)
        #  print(self.c1)

        # calc spline coefficient b and d
        for i in range(self.nx - 1):
            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))
            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \
                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0
            self.b.append(tb)

    def calc(self, t):
        &#34;&#34;&#34;
        Calc position

        if t is outside of the input x, return None

        &#34;&#34;&#34;

        if t &lt; self.x[0]:
            return None
        elif t &gt; self.x[-1]:
            return None

        i = self.__search_index(t)
        dx = t - self.x[i]
        result = self.a[i] + self.b[i] * dx + \
            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0

        return result

    def calcd(self, t):
        &#34;&#34;&#34;
        Calc first derivative

        if t is outside of the input x, return None
        &#34;&#34;&#34;

        if t &lt; self.x[0]:
            return None
        elif t &gt; self.x[-1]:
            return None

        i = self.__search_index(t)
        dx = t - self.x[i]
        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0
        return result

    def calcdd(self, t):
        &#34;&#34;&#34;
        Calc second derivative
        &#34;&#34;&#34;

        if t &lt; self.x[0]:
            return None
        elif t &gt; self.x[-1]:
            return None

        i = self.__search_index(t)
        dx = t - self.x[i]
        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx
        return result

    def __search_index(self, x):
        &#34;&#34;&#34;
        search data segment index
        &#34;&#34;&#34;
        return bisect.bisect(self.x, x) - 1

    def __calc_A(self, h):
        &#34;&#34;&#34;
        calc matrix A for spline coefficient c
        &#34;&#34;&#34;
        A = np.zeros((self.nx, self.nx))
        A[0, 0] = 1.0
        for i in range(self.nx - 1):
            if i != (self.nx - 2):
                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])
            A[i + 1, i] = h[i]
            A[i, i + 1] = h[i]

        A[0, 1] = 0.0
        A[self.nx - 1, self.nx - 2] = 0.0
        A[self.nx - 1, self.nx - 1] = 1.0
        #  print(A)
        return A

    def __calc_B(self, h):
        &#34;&#34;&#34;
        calc matrix B for spline coefficient c
        &#34;&#34;&#34;
        B = np.zeros(self.nx)
        for i in range(self.nx - 2):
            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \
                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]
        return B</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="opencda.core.plan.spline.Spline.calc"><code class="name flex">
<span>def <span class="ident">calc</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calc position</p>
<p>if t is outside of the input x, return None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc(self, t):
    &#34;&#34;&#34;
    Calc position

    if t is outside of the input x, return None

    &#34;&#34;&#34;

    if t &lt; self.x[0]:
        return None
    elif t &gt; self.x[-1]:
        return None

    i = self.__search_index(t)
    dx = t - self.x[i]
    result = self.a[i] + self.b[i] * dx + \
        self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0

    return result</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.spline.Spline.calcd"><code class="name flex">
<span>def <span class="ident">calcd</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calc first derivative</p>
<p>if t is outside of the input x, return None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcd(self, t):
    &#34;&#34;&#34;
    Calc first derivative

    if t is outside of the input x, return None
    &#34;&#34;&#34;

    if t &lt; self.x[0]:
        return None
    elif t &gt; self.x[-1]:
        return None

    i = self.__search_index(t)
    dx = t - self.x[i]
    result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0
    return result</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.spline.Spline.calcdd"><code class="name flex">
<span>def <span class="ident">calcdd</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calc second derivative</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcdd(self, t):
    &#34;&#34;&#34;
    Calc second derivative
    &#34;&#34;&#34;

    if t &lt; self.x[0]:
        return None
    elif t &gt; self.x[-1]:
        return None

    i = self.__search_index(t)
    dx = t - self.x[i]
    result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opencda.core.plan.spline.Spline2D"><code class="flex name class">
<span>class <span class="ident">Spline2D</span></span>
<span>(</span><span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>2D Cubic Spline class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spline2D:
    &#34;&#34;&#34;
    2D Cubic Spline class

    &#34;&#34;&#34;

    def __init__(self, x, y):
        self.s = self.__calc_s(x, y)
        self.sx = Spline(self.s, x)
        self.sy = Spline(self.s, y)

    def __calc_s(self, x, y):
        dx = np.diff(x)
        dy = np.diff(y)
        self.ds = np.hypot(dx, dy)
        s = [0]
        s.extend(np.cumsum(self.ds))
        return s

    def calc_position(self, s):
        &#34;&#34;&#34;
        calc position
        &#34;&#34;&#34;
        x = self.sx.calc(s)
        y = self.sy.calc(s)

        return x, y

    def calc_curvature(self, s):
        &#34;&#34;&#34;
        calc curvature
        &#34;&#34;&#34;
        dx = self.sx.calcd(s)
        ddx = self.sx.calcdd(s)
        dy = self.sy.calcd(s)
        ddy = self.sy.calcdd(s)
        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))
        return k

    def calc_yaw(self, s):
        &#34;&#34;&#34;
        calc yaw
        &#34;&#34;&#34;
        dx = self.sx.calcd(s)
        dy = self.sy.calcd(s)
        yaw = math.atan2(dy, dx)
        return yaw</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="opencda.core.plan.spline.Spline2D.calc_curvature"><code class="name flex">
<span>def <span class="ident">calc_curvature</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>calc curvature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_curvature(self, s):
    &#34;&#34;&#34;
    calc curvature
    &#34;&#34;&#34;
    dx = self.sx.calcd(s)
    ddx = self.sx.calcdd(s)
    dy = self.sy.calcd(s)
    ddy = self.sy.calcdd(s)
    k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))
    return k</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.spline.Spline2D.calc_position"><code class="name flex">
<span>def <span class="ident">calc_position</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>calc position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_position(self, s):
    &#34;&#34;&#34;
    calc position
    &#34;&#34;&#34;
    x = self.sx.calc(s)
    y = self.sy.calc(s)

    return x, y</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.spline.Spline2D.calc_yaw"><code class="name flex">
<span>def <span class="ident">calc_yaw</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>calc yaw</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_yaw(self, s):
    &#34;&#34;&#34;
    calc yaw
    &#34;&#34;&#34;
    dx = self.sx.calcd(s)
    dy = self.sy.calcd(s)
    yaw = math.atan2(dy, dx)
    return yaw</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opencda.core.plan" href="index.html">opencda.core.plan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opencda.core.plan.spline.calc_spline_course" href="#opencda.core.plan.spline.calc_spline_course">calc_spline_course</a></code></li>
<li><code><a title="opencda.core.plan.spline.main" href="#opencda.core.plan.spline.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opencda.core.plan.spline.Spline" href="#opencda.core.plan.spline.Spline">Spline</a></code></h4>
<ul class="">
<li><code><a title="opencda.core.plan.spline.Spline.calc" href="#opencda.core.plan.spline.Spline.calc">calc</a></code></li>
<li><code><a title="opencda.core.plan.spline.Spline.calcd" href="#opencda.core.plan.spline.Spline.calcd">calcd</a></code></li>
<li><code><a title="opencda.core.plan.spline.Spline.calcdd" href="#opencda.core.plan.spline.Spline.calcdd">calcdd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opencda.core.plan.spline.Spline2D" href="#opencda.core.plan.spline.Spline2D">Spline2D</a></code></h4>
<ul class="">
<li><code><a title="opencda.core.plan.spline.Spline2D.calc_curvature" href="#opencda.core.plan.spline.Spline2D.calc_curvature">calc_curvature</a></code></li>
<li><code><a title="opencda.core.plan.spline.Spline2D.calc_position" href="#opencda.core.plan.spline.Spline2D.calc_position">calc_position</a></code></li>
<li><code><a title="opencda.core.plan.spline.Spline2D.calc_yaw" href="#opencda.core.plan.spline.Spline2D.calc_yaw">calc_yaw</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
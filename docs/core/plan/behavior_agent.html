<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>opencda.core.plan.behavior_agent API documentation</title>
<meta name="description" content="This module implements an agent that roams around a track following random
waypoints and avoiding other vehicles. The agent also responds to traffic â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>opencda.core.plan.behavior_agent</code></h1>
</header>
<section id="section-intro">
<p>This module implements an agent that roams around a track following random
waypoints and avoiding other vehicles. The agent also responds to traffic lights,
traffic signs, and has different possible configurations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) # Copyright (c) 2018-2020 CVC.
#
# This work is licensed under the terms of the MIT license.
# For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.


&#34;&#34;&#34; This module implements an agent that roams around a track following random
waypoints and avoiding other vehicles. The agent also responds to traffic lights,
traffic signs, and has different possible configurations. &#34;&#34;&#34;

import random
import sys

import numpy as np
import carla

from opencda.core.common.misc import get_speed, positive, cal_distance_angle
from opencda.core.plan.collision_check import CollisionChecker
from opencda.core.plan.local_planner_behavior import LocalPlanner
from opencda.core.plan.global_route_planner import GlobalRoutePlanner
from opencda.core.plan.global_route_planner_dao import GlobalRoutePlannerDAO
from opencda.core.plan.planer_debug_helper import PlanDebugHelper


class BehaviorAgent(object):
    &#34;&#34;&#34;
    A modulized version of BehaviorAgent
    &#34;&#34;&#34;

    def __init__(self, vehicle, carla_map, config_yaml):
        &#34;&#34;&#34;
        Construct class
        :param vehicle: carla actor
        :param config_yaml: a dictionary containing all initialization params
        provide customized function under customize/controller
        &#34;&#34;&#34;

        self.vehicle = vehicle
        # ego pos(transform) and speed(km/h) retrieved from localization module
        self._ego_pos = None
        self._ego_speed = 0.0
        self._map = carla_map

        # speed related, check yaml file to see the meaning
        self.max_speed = config_yaml[&#39;max_speed&#39;]
        self.tailgate_speed = config_yaml[&#39;tailgate_speed&#39;]
        self.speed_lim_dist = config_yaml[&#39;speed_lim_dist&#39;]
        self.speed_decrease = config_yaml[&#39;speed_decrease&#39;]
        self.min_speed = 5

        # safety related
        self.safety_time = config_yaml[&#39;safety_time&#39;]
        self.emergency_param = config_yaml[&#39;emergency_param&#39;]
        self.break_distance = 0
        self.ttc = 1000
        # collision checker
        self._collision_check = CollisionChecker(time_ahead=config_yaml[&#39;collision_time_ahead&#39;])
        self.ignore_traffic_light = config_yaml[&#39;ignore_traffic_light&#39;]
        self.overtake_allowed = config_yaml[&#39;overtake_allowed&#39;]
        self.overtake_counter = 0  # TODO: MODIFY THIS LATER
        # used to indicate whether a vehicle is on the planned path
        self.hazard_flag = False

        # route planner related
        self._global_planner = None
        self.start_waypoint = None
        self.end_waypoint = None
        self._sampling_resolution = config_yaml[&#39;sample_resolution&#39;]

        # intersection agent related
        self.light_state = &#34;Red&#34;
        self.light_id_to_ignore = -1

        # trajectory planner
        self._local_planner = LocalPlanner(self, carla_map, config_yaml[&#39;local_planner&#39;])

        # special behavior rlated
        self.car_following_flag = False
        # lane change allowed flag
        self.lane_change_allowed = True
        # destination temp push flag
        self.destination_push_flag = False

        # white list of vehicle managers that the cav does not consider as obstacles
        self.white_list = []
        self.obstacle_vehicles = []

        # debug helper
        self.debug_helper = PlanDebugHelper(self.vehicle.id)

    def update_information(self, ego_pos, ego_speed, objects):
        &#34;&#34;&#34;
        Update the perception and localization information to the behavior agent.
        Args:
            ego_pos (carla.Transform): ego position from localization module.
            ego_speed (float): km/h, ego speed.
            objects (dictionary): Objects detection results from perception module.
        &#34;&#34;&#34;
        # update localization information
        self._ego_speed = ego_speed
        self._ego_pos = ego_pos
        self.break_distance = self._ego_speed / 3.6 * self.emergency_param
        # update the localization info to trajectory planner
        self.get_local_planner().update_information(ego_pos, ego_speed)

        # current version only consider about vehicles
        obstacle_vehicles = objects[&#39;vehicles&#39;]
        self.obstacle_vehicles = self.white_list_match(obstacle_vehicles)

        # update the debug helper
        self.debug_helper.update(ego_speed, self.ttc)

        if self.ignore_traffic_light:
            self.light_state = &#34;Green&#34;
        else:
            # This method also includes stop signs and intersections.
            self.light_state = str(self.vehicle.get_traffic_light_state())

    def add_white_list(self, vm):
        &#34;&#34;&#34;
        Add vehicle manager to
        Args:
            vm ():

        Returns:

        &#34;&#34;&#34;
        self.white_list.append(vm)

    def white_list_match(self, obstacles):
        &#34;&#34;&#34;
        Match the detected obstacles with the white list. Remove the obstacles that are in white list.
        The white list contains all position of target platoon member for joining.
        Args:
            obstacles (list):  a list of carla.Vehicle or ObstacleVehicle

        Returns:
            (list): the new list of obstacles.
        &#34;&#34;&#34;
        new_obstacle_list = []

        for o in obstacles:
            flag = False
            o_x = o.get_location().x
            o_y = o.get_location().y

            o_waypoint = self._map.get_waypoint(o.get_location())
            o_lane_id = o_waypoint.lane_id

            for vm in self.white_list:
                pos = vm.localizer.get_ego_pos()
                vm_x = pos.location.x
                vm_y = pos.location.y

                w_waypoint = self._map.get_waypoint(pos.location)
                w_lane_id = w_waypoint.lane_id

                # if the id is different, then not matched for sure
                if o_lane_id != w_lane_id:
                    continue

                if abs(vm_x - o_x) &lt;= 3.0 and abs(vm_y - o_y) &lt;= 3.0:
                    flag = True
                    break
            if not flag:
                new_obstacle_list.append(o)

        return new_obstacle_list

    def set_destination(self, start_location, end_location, clean=False, end_reset=True, clean_history=False):
        &#34;&#34;&#34;
        This method creates a list of waypoints from agent&#39;s position to destination location
        based on the route returned by the global router.

            :param end_reset: indicates whether the new destination is a temporary destination
            :param start_location: initial position
            :param end_location: final position
            :param clean: boolean to clean the waypoint queue
            :param clean_history:
        &#34;&#34;&#34;
        if clean:
            self.get_local_planner().waypoints_queue.clear()
            self.get_local_planner().get_trajetory().clear()
            self.get_local_planner()._waypoint_buffer.clear()
        if clean_history:
            self.get_local_planner()._history_buffer.clear()

        self.start_waypoint = self._map.get_waypoint(start_location)

        # make sure the start waypoint is behind the vehicle
        if self._ego_pos:
            cur_loc = self._ego_pos.location
            cur_yaw = self._ego_pos.rotation.yaw
            _, angle = cal_distance_angle(self.start_waypoint.transform.location, cur_loc, cur_yaw)

            while angle &gt; 90:
                self.start_waypoint = self.start_waypoint.next(1)[0]
                _, angle = cal_distance_angle(self.start_waypoint.transform.location, cur_loc, cur_yaw)

        end_waypoint = self._map.get_waypoint(end_location)
        if end_reset:
            self.end_waypoint = end_waypoint

        route_trace = self._trace_route(self.start_waypoint, end_waypoint)

        self._local_planner.set_global_plan(route_trace, clean)

    def get_local_planner(self):
        &#34;&#34;&#34;return the local planner
        &#34;&#34;&#34;
        return self._local_planner

    def reroute(self, spawn_points):
        &#34;&#34;&#34;
        This method implements re-routing for vehicles approaching its destination.
        It finds a new target and computes another path to reach it.

            :param spawn_points: list of possible destinations for the agent
        &#34;&#34;&#34;

        print(&#34;Target almost reached, setting new destination...&#34;)
        random.shuffle(spawn_points)
        new_start = self._local_planner.waypoints_queue[-1][0].transform.location
        destination = spawn_points[0].location if spawn_points[0].location != new_start else spawn_points[1].location
        print(&#34;New destination: &#34; + str(destination))

        self.set_destination(new_start, destination)

    def _trace_route(self, start_waypoint, end_waypoint):
        &#34;&#34;&#34;
        This method sets up a global router and returns the
        optimal route from start_waypoint to end_waypoint.

            :param start_waypoint: initial position
            :param end_waypoint: final position
        &#34;&#34;&#34;
        # Setting up global router
        if self._global_planner is None:
            wld = self.vehicle.get_world()
            dao = GlobalRoutePlannerDAO(
                wld.get_map(), sampling_resolution=self._sampling_resolution)
            grp = GlobalRoutePlanner(dao)
            grp.setup()
            self._global_planner = grp

        # Obtain route plan
        route = self._global_planner.trace_route(
            start_waypoint.transform.location,
            end_waypoint.transform.location)

        return route

    def traffic_light_manager(self, waypoint):
        &#34;&#34;&#34;
        This method is in charge of behaviors for red lights and stops.

        WARNING: What follows is a proxy to avoid having a car brake after running a yellow light.
        This happens because the car is still under the influence of the semaphore,
        even after passing it. So, the semaphore id is temporarely saved to
        ignore it and go around this issue, until the car is near a new one.

            :param waypoint: current waypoint of the agent
        &#34;&#34;&#34;

        light_id = self.vehicle.get_traffic_light().id if self.vehicle.get_traffic_light() is not None else -1

        if self.light_state == &#34;Red&#34;:
            if not waypoint.is_junction and (self.light_id_to_ignore != light_id or light_id == -1):
                return 1
            elif waypoint.is_junction and light_id != -1:
                self.light_id_to_ignore = light_id
        if self.light_id_to_ignore != light_id:
            self.light_id_to_ignore = -1
        return 0

    def collision_manager(self, rx, ry, ryaw, waypoint, adjacent_check=False):
        &#34;&#34;&#34;
        This module is in charge of warning in case of a collision
        :param adjacent_check: whether it is a check for adjacent lane
        :param rx: x coordinates of plan path
        :param ry: y coordinates of plan path
        :param ryaw: yaw angle
        :param waypoint: current waypoint of the agent
        :return vehicle_state: True if there is a vehicle nearby, False if not
        :return vehicle: nearby vehicle
        :return distance: distance to nearby vehicle
        &#34;&#34;&#34;

        def dist(v):
            return v.get_location().distance(waypoint.transform.location)

        vehicle_state = False
        min_distance = 100000
        target_vehicle = None

        for vehicle in self.obstacle_vehicles:
            collision_free = self._collision_check.collision_circle_check(rx, ry, ryaw, vehicle,
                                                                          self._ego_speed / 3.6,
                                                                          adjacent_check=adjacent_check)
            if not collision_free:
                vehicle_state = True
                distance = dist(vehicle)
                if distance &lt; min_distance:
                    min_distance = distance
                    target_vehicle = vehicle

        return vehicle_state, target_vehicle, min_distance

    def overtake_management(self, obstacle_vehicle):
        &#34;&#34;&#34;
        Overtake behavior.
        :param obstacle_vehicle: the vehicle
        :return:
        &#34;&#34;&#34;
        # obstacle vehicle&#39;s location
        obstacle_vehicle_loc = obstacle_vehicle.get_location()
        obstacle_vehicle_wpt = self._map.get_waypoint(obstacle_vehicle_loc)

        # whether a lane change is allowed
        left_turn = obstacle_vehicle_wpt.left_lane_marking.lane_change
        right_turn = obstacle_vehicle_wpt.right_lane_marking.lane_change

        # left and right waypoint of the obstacle vehicle
        left_wpt = obstacle_vehicle_wpt.get_left_lane()
        right_wpt = obstacle_vehicle_wpt.get_right_lane()

        # if the vehicle is able to operate left overtake
        if (left_turn == carla.LaneChange.Left or left_turn ==
            carla.LaneChange.Both) and left_wpt and obstacle_vehicle_wpt.lane_id * left_wpt.lane_id &gt; 0 \
                and left_wpt.lane_type == carla.LaneType.Driving:
            # this not the real plan path, but just a quick path to check collision
            rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                               target_wpt=left_wpt,
                                                                               overtake=True,
                                                                               world=self.vehicle.get_world())
            vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                         self._map.get_waypoint(self._ego_pos.location),
                                                         True)
            if not vehicle_state:
                print(&#34;left overtake is operated&#34;)
                self.overtake_counter = 100
                next_wpt = left_wpt.next(self._ego_speed / 3.6 * 6)[0]
                left_wpt = left_wpt.next(5)[0]
                self.set_destination(left_wpt.transform.location, next_wpt.transform.location,
                                     clean=True, end_reset=False)
                return vehicle_state

        if (right_turn == carla.LaneChange.Right or right_turn ==
            carla.LaneChange.Both) and right_wpt and obstacle_vehicle_wpt.lane_id * right_wpt.lane_id &gt; 0 \
                and right_wpt.lane_type == carla.LaneType.Driving:
            rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                               target_wpt=right_wpt,
                                                                               overtake=True,
                                                                               world=self.vehicle.get_world())
            vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                         self._map.get_waypoint(self._ego_pos.location),
                                                         True)
            if not vehicle_state:
                print(&#34;right overtake is operated&#34;)
                self.overtake_counter = 100
                next_wpt = right_wpt.next(self._ego_speed / 3.6 * 6)[0]
                right_wpt = right_wpt.next(5)[0]
                self.set_destination(right_wpt.transform.location, next_wpt.transform.location,
                                     clean=True, end_reset=False)
                return vehicle_state

        return True

    def lane_change_management(self):
        &#34;&#34;&#34;
        Identify whether a potential hazard exits if operating lane change.
        Returns:
            bool: whether the lane change is dangerous
        &#34;&#34;&#34;
        ego_wpt = self._map.get_waypoint(self._ego_pos.location)
        ego_lane_id = ego_wpt.lane_id
        target_wpt = None

        # check the closest waypoint on the adjacent lane
        for wpt in self.get_local_planner()._waypoint_buffer:
            if wpt[0].lane_id != ego_lane_id:
                target_wpt = wpt[0]
                break
        if not target_wpt:
            return False

        rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                           target_wpt=target_wpt,
                                                                           overtake=False,
                                                                           world=self.vehicle.get_world())
        vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                     self._map.get_waypoint(self._ego_pos.location),
                                                     adjacent_check=True)
        return not vehicle_state

    def car_following_manager(self, vehicle, distance, target_speed=None):
        &#34;&#34;&#34;
        Module in charge of car-following behaviors when there&#39;s
        someone in front of us.

            :param target_speed:
            :param vehicle: car to follow
            :param distance: distance from vehicle
            :return control: carla.VehicleControl
        &#34;&#34;&#34;
        if not target_speed:
            target_speed = self.max_speed - self.speed_lim_dist

        vehicle_speed = get_speed(vehicle)

        delta_v = max(1, (self._ego_speed - vehicle_speed) / 3.6)
        ttc = distance / delta_v if delta_v != 0 else distance / np.nextafter(0., 1.)
        self.ttc = ttc
        # Under safety time distance, slow down.
        if self.safety_time &gt; ttc &gt; 0.0:
            target_speed = min(positive(vehicle_speed - self.speed_decrease),
                               target_speed)
            print(&#34;vehicle id %d: car following decreasing speed mode, target speed %f&#34;
                  % (self.vehicle.id, target_speed))

        # Actual safety distance area, try to follow the speed of the vehicle in front.
        else:
            target_speed = min(max(self.min_speed, vehicle_speed + 1),
                               target_speed)
            print(&#34;vehicle id %d: car following keep speed mode, target speed %f&#34;
                  % (self.vehicle.id, target_speed))
        return target_speed

    def run_step(self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True):
        &#34;&#34;&#34;
        Execute one step of navigation
        :param collision_detector_enabled: whether to enable collision detection.
        :param target_speed:  a manual order to achieve certain speed.
        :param lane_change_allowed: whether lane change is allowed. This is passed from platoon behavior agent.
        :return: control: carla.VehicleControl
        &#34;&#34;&#34;
        # retrieve ego location
        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_wp = self._map.get_waypoint(ego_vehicle_loc)
        # ttc reset to 1000 at the beginning
        self.ttc = 1000

        # simulation ends condition
        if abs(self._ego_pos.location.x - self.end_waypoint.transform.location.x) &lt;= 10 and \
                abs(self._ego_pos.location.y - self.end_waypoint.transform.location.y) &lt;= 10:
            print(&#39;Simulation is Over&#39;)
            sys.exit(0)

        # when overtake_counter &gt; 0, another overtake/lane change is forbidden
        if self.overtake_counter &gt; 0:
            self.overtake_counter -= 1

        # 1: Traffic light management
        if self.traffic_light_manager(ego_vehicle_wp) != 0:
            return 0, None

        # when the temporary route is finished, we return to the global route
        if len(self.get_local_planner().waypoints_queue) == 0 \
                and len(self.get_local_planner()._waypoint_buffer) &lt;= 2:
            print(&#39;Destination Reset!&#39;)
            self.overtake_allowed = True
            self.destination_push_flag = False
            self.set_destination(ego_vehicle_loc, self.end_waypoint.transform.location, clean=True, clean_history=True)

        # 2: Path generation based on the global route
        rx, ry, rk, ryaw = self._local_planner.generate_path()

        # check whether lane change is allowed
        if collision_detector_enabled and \
                self.get_local_planner().lane_id_change and \
                self.overtake_counter &lt;= 0 and \
                not self.destination_push_flag:
            self.lane_change_allowed = lane_change_allowed and self.lane_change_management()

        # 3: Collision check
        is_hazard = False
        if collision_detector_enabled:
            is_hazard, obstacle_vehicle, distance = self.collision_manager(rx, ry, ryaw, ego_vehicle_wp)
        car_following_flag = False

        if not is_hazard:
            self.hazard_flag = False

        # the case that the vehicle is doing lane change as planned but found vehicle blocking on the other lane
        if not self.lane_change_allowed and self.get_local_planner().lane_id_change \
                and not self.destination_push_flag and self.overtake_counter &lt;= 0:
            self.overtake_allowed = False
            reset_target = ego_vehicle_wp.next(self._ego_speed / 3.6 * 3)[0]
            print(&#39;destination pushed forward because of potential collision&#39;)

            self.destination_push_flag = True
            self.set_destination(ego_vehicle_loc, reset_target.transform.location, clean=True,
                                 end_reset=False)

            rx, ry, rk, ryaw = self._local_planner.generate_path()

        # the case that vehicle is blocking in front and overtake not allowed or it is doing overtaking
        # the second condition is to prevent successive overtaking
        elif is_hazard and (not self.overtake_allowed or self.overtake_counter &gt; 0
                            or self.get_local_planner().lane_change):
            car_following_flag = True

        elif is_hazard and self.overtake_allowed and self.overtake_counter &lt;= 0:
            obstacle_speed = get_speed(obstacle_vehicle)
            obstacle_lane_id = self._map.get_waypoint(obstacle_vehicle.get_location()).lane_id
            ego_lane_id = self._map.get_waypoint(self._ego_pos.location).lane_id

            # overtake the obstacle vehicle only when speed is bigger and the lane id is the same
            if ego_lane_id == obstacle_lane_id:
                # this flag is used for transition from cut-in joining to back joining
                self.hazard_flag = is_hazard
                # we only consider overtaking when speed is faster than the front obstacle
                if self._ego_speed &gt;= obstacle_speed - 5:
                    car_following_flag = self.overtake_management(obstacle_vehicle)
                else:
                    car_following_flag = True

        # 4. Car following behavior
        if car_following_flag:

            if distance &lt; self.break_distance:
                return 0, None

            target_speed = self.car_following_manager(obstacle_vehicle, distance, target_speed)
            target_speed, target_loc = self._local_planner.run_step(rx, ry, rk, target_speed=target_speed)
            return target_speed, target_loc

        # 5. Normal behavior
        target_speed, target_loc = self._local_planner.run_step(rx, ry, rk,
                                                                target_speed=self.max_speed - self.speed_lim_dist
                                                                if not target_speed else target_speed)

        return target_speed, target_loc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent"><code class="flex name class">
<span>class <span class="ident">BehaviorAgent</span></span>
<span>(</span><span>vehicle, carla_map, config_yaml)</span>
</code></dt>
<dd>
<div class="desc"><p>A modulized version of BehaviorAgent</p>
<p>Construct class
:param vehicle: carla actor
:param config_yaml: a dictionary containing all initialization params
provide customized function under customize/controller</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BehaviorAgent(object):
    &#34;&#34;&#34;
    A modulized version of BehaviorAgent
    &#34;&#34;&#34;

    def __init__(self, vehicle, carla_map, config_yaml):
        &#34;&#34;&#34;
        Construct class
        :param vehicle: carla actor
        :param config_yaml: a dictionary containing all initialization params
        provide customized function under customize/controller
        &#34;&#34;&#34;

        self.vehicle = vehicle
        # ego pos(transform) and speed(km/h) retrieved from localization module
        self._ego_pos = None
        self._ego_speed = 0.0
        self._map = carla_map

        # speed related, check yaml file to see the meaning
        self.max_speed = config_yaml[&#39;max_speed&#39;]
        self.tailgate_speed = config_yaml[&#39;tailgate_speed&#39;]
        self.speed_lim_dist = config_yaml[&#39;speed_lim_dist&#39;]
        self.speed_decrease = config_yaml[&#39;speed_decrease&#39;]
        self.min_speed = 5

        # safety related
        self.safety_time = config_yaml[&#39;safety_time&#39;]
        self.emergency_param = config_yaml[&#39;emergency_param&#39;]
        self.break_distance = 0
        self.ttc = 1000
        # collision checker
        self._collision_check = CollisionChecker(time_ahead=config_yaml[&#39;collision_time_ahead&#39;])
        self.ignore_traffic_light = config_yaml[&#39;ignore_traffic_light&#39;]
        self.overtake_allowed = config_yaml[&#39;overtake_allowed&#39;]
        self.overtake_counter = 0  # TODO: MODIFY THIS LATER
        # used to indicate whether a vehicle is on the planned path
        self.hazard_flag = False

        # route planner related
        self._global_planner = None
        self.start_waypoint = None
        self.end_waypoint = None
        self._sampling_resolution = config_yaml[&#39;sample_resolution&#39;]

        # intersection agent related
        self.light_state = &#34;Red&#34;
        self.light_id_to_ignore = -1

        # trajectory planner
        self._local_planner = LocalPlanner(self, carla_map, config_yaml[&#39;local_planner&#39;])

        # special behavior rlated
        self.car_following_flag = False
        # lane change allowed flag
        self.lane_change_allowed = True
        # destination temp push flag
        self.destination_push_flag = False

        # white list of vehicle managers that the cav does not consider as obstacles
        self.white_list = []
        self.obstacle_vehicles = []

        # debug helper
        self.debug_helper = PlanDebugHelper(self.vehicle.id)

    def update_information(self, ego_pos, ego_speed, objects):
        &#34;&#34;&#34;
        Update the perception and localization information to the behavior agent.
        Args:
            ego_pos (carla.Transform): ego position from localization module.
            ego_speed (float): km/h, ego speed.
            objects (dictionary): Objects detection results from perception module.
        &#34;&#34;&#34;
        # update localization information
        self._ego_speed = ego_speed
        self._ego_pos = ego_pos
        self.break_distance = self._ego_speed / 3.6 * self.emergency_param
        # update the localization info to trajectory planner
        self.get_local_planner().update_information(ego_pos, ego_speed)

        # current version only consider about vehicles
        obstacle_vehicles = objects[&#39;vehicles&#39;]
        self.obstacle_vehicles = self.white_list_match(obstacle_vehicles)

        # update the debug helper
        self.debug_helper.update(ego_speed, self.ttc)

        if self.ignore_traffic_light:
            self.light_state = &#34;Green&#34;
        else:
            # This method also includes stop signs and intersections.
            self.light_state = str(self.vehicle.get_traffic_light_state())

    def add_white_list(self, vm):
        &#34;&#34;&#34;
        Add vehicle manager to
        Args:
            vm ():

        Returns:

        &#34;&#34;&#34;
        self.white_list.append(vm)

    def white_list_match(self, obstacles):
        &#34;&#34;&#34;
        Match the detected obstacles with the white list. Remove the obstacles that are in white list.
        The white list contains all position of target platoon member for joining.
        Args:
            obstacles (list):  a list of carla.Vehicle or ObstacleVehicle

        Returns:
            (list): the new list of obstacles.
        &#34;&#34;&#34;
        new_obstacle_list = []

        for o in obstacles:
            flag = False
            o_x = o.get_location().x
            o_y = o.get_location().y

            o_waypoint = self._map.get_waypoint(o.get_location())
            o_lane_id = o_waypoint.lane_id

            for vm in self.white_list:
                pos = vm.localizer.get_ego_pos()
                vm_x = pos.location.x
                vm_y = pos.location.y

                w_waypoint = self._map.get_waypoint(pos.location)
                w_lane_id = w_waypoint.lane_id

                # if the id is different, then not matched for sure
                if o_lane_id != w_lane_id:
                    continue

                if abs(vm_x - o_x) &lt;= 3.0 and abs(vm_y - o_y) &lt;= 3.0:
                    flag = True
                    break
            if not flag:
                new_obstacle_list.append(o)

        return new_obstacle_list

    def set_destination(self, start_location, end_location, clean=False, end_reset=True, clean_history=False):
        &#34;&#34;&#34;
        This method creates a list of waypoints from agent&#39;s position to destination location
        based on the route returned by the global router.

            :param end_reset: indicates whether the new destination is a temporary destination
            :param start_location: initial position
            :param end_location: final position
            :param clean: boolean to clean the waypoint queue
            :param clean_history:
        &#34;&#34;&#34;
        if clean:
            self.get_local_planner().waypoints_queue.clear()
            self.get_local_planner().get_trajetory().clear()
            self.get_local_planner()._waypoint_buffer.clear()
        if clean_history:
            self.get_local_planner()._history_buffer.clear()

        self.start_waypoint = self._map.get_waypoint(start_location)

        # make sure the start waypoint is behind the vehicle
        if self._ego_pos:
            cur_loc = self._ego_pos.location
            cur_yaw = self._ego_pos.rotation.yaw
            _, angle = cal_distance_angle(self.start_waypoint.transform.location, cur_loc, cur_yaw)

            while angle &gt; 90:
                self.start_waypoint = self.start_waypoint.next(1)[0]
                _, angle = cal_distance_angle(self.start_waypoint.transform.location, cur_loc, cur_yaw)

        end_waypoint = self._map.get_waypoint(end_location)
        if end_reset:
            self.end_waypoint = end_waypoint

        route_trace = self._trace_route(self.start_waypoint, end_waypoint)

        self._local_planner.set_global_plan(route_trace, clean)

    def get_local_planner(self):
        &#34;&#34;&#34;return the local planner
        &#34;&#34;&#34;
        return self._local_planner

    def reroute(self, spawn_points):
        &#34;&#34;&#34;
        This method implements re-routing for vehicles approaching its destination.
        It finds a new target and computes another path to reach it.

            :param spawn_points: list of possible destinations for the agent
        &#34;&#34;&#34;

        print(&#34;Target almost reached, setting new destination...&#34;)
        random.shuffle(spawn_points)
        new_start = self._local_planner.waypoints_queue[-1][0].transform.location
        destination = spawn_points[0].location if spawn_points[0].location != new_start else spawn_points[1].location
        print(&#34;New destination: &#34; + str(destination))

        self.set_destination(new_start, destination)

    def _trace_route(self, start_waypoint, end_waypoint):
        &#34;&#34;&#34;
        This method sets up a global router and returns the
        optimal route from start_waypoint to end_waypoint.

            :param start_waypoint: initial position
            :param end_waypoint: final position
        &#34;&#34;&#34;
        # Setting up global router
        if self._global_planner is None:
            wld = self.vehicle.get_world()
            dao = GlobalRoutePlannerDAO(
                wld.get_map(), sampling_resolution=self._sampling_resolution)
            grp = GlobalRoutePlanner(dao)
            grp.setup()
            self._global_planner = grp

        # Obtain route plan
        route = self._global_planner.trace_route(
            start_waypoint.transform.location,
            end_waypoint.transform.location)

        return route

    def traffic_light_manager(self, waypoint):
        &#34;&#34;&#34;
        This method is in charge of behaviors for red lights and stops.

        WARNING: What follows is a proxy to avoid having a car brake after running a yellow light.
        This happens because the car is still under the influence of the semaphore,
        even after passing it. So, the semaphore id is temporarely saved to
        ignore it and go around this issue, until the car is near a new one.

            :param waypoint: current waypoint of the agent
        &#34;&#34;&#34;

        light_id = self.vehicle.get_traffic_light().id if self.vehicle.get_traffic_light() is not None else -1

        if self.light_state == &#34;Red&#34;:
            if not waypoint.is_junction and (self.light_id_to_ignore != light_id or light_id == -1):
                return 1
            elif waypoint.is_junction and light_id != -1:
                self.light_id_to_ignore = light_id
        if self.light_id_to_ignore != light_id:
            self.light_id_to_ignore = -1
        return 0

    def collision_manager(self, rx, ry, ryaw, waypoint, adjacent_check=False):
        &#34;&#34;&#34;
        This module is in charge of warning in case of a collision
        :param adjacent_check: whether it is a check for adjacent lane
        :param rx: x coordinates of plan path
        :param ry: y coordinates of plan path
        :param ryaw: yaw angle
        :param waypoint: current waypoint of the agent
        :return vehicle_state: True if there is a vehicle nearby, False if not
        :return vehicle: nearby vehicle
        :return distance: distance to nearby vehicle
        &#34;&#34;&#34;

        def dist(v):
            return v.get_location().distance(waypoint.transform.location)

        vehicle_state = False
        min_distance = 100000
        target_vehicle = None

        for vehicle in self.obstacle_vehicles:
            collision_free = self._collision_check.collision_circle_check(rx, ry, ryaw, vehicle,
                                                                          self._ego_speed / 3.6,
                                                                          adjacent_check=adjacent_check)
            if not collision_free:
                vehicle_state = True
                distance = dist(vehicle)
                if distance &lt; min_distance:
                    min_distance = distance
                    target_vehicle = vehicle

        return vehicle_state, target_vehicle, min_distance

    def overtake_management(self, obstacle_vehicle):
        &#34;&#34;&#34;
        Overtake behavior.
        :param obstacle_vehicle: the vehicle
        :return:
        &#34;&#34;&#34;
        # obstacle vehicle&#39;s location
        obstacle_vehicle_loc = obstacle_vehicle.get_location()
        obstacle_vehicle_wpt = self._map.get_waypoint(obstacle_vehicle_loc)

        # whether a lane change is allowed
        left_turn = obstacle_vehicle_wpt.left_lane_marking.lane_change
        right_turn = obstacle_vehicle_wpt.right_lane_marking.lane_change

        # left and right waypoint of the obstacle vehicle
        left_wpt = obstacle_vehicle_wpt.get_left_lane()
        right_wpt = obstacle_vehicle_wpt.get_right_lane()

        # if the vehicle is able to operate left overtake
        if (left_turn == carla.LaneChange.Left or left_turn ==
            carla.LaneChange.Both) and left_wpt and obstacle_vehicle_wpt.lane_id * left_wpt.lane_id &gt; 0 \
                and left_wpt.lane_type == carla.LaneType.Driving:
            # this not the real plan path, but just a quick path to check collision
            rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                               target_wpt=left_wpt,
                                                                               overtake=True,
                                                                               world=self.vehicle.get_world())
            vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                         self._map.get_waypoint(self._ego_pos.location),
                                                         True)
            if not vehicle_state:
                print(&#34;left overtake is operated&#34;)
                self.overtake_counter = 100
                next_wpt = left_wpt.next(self._ego_speed / 3.6 * 6)[0]
                left_wpt = left_wpt.next(5)[0]
                self.set_destination(left_wpt.transform.location, next_wpt.transform.location,
                                     clean=True, end_reset=False)
                return vehicle_state

        if (right_turn == carla.LaneChange.Right or right_turn ==
            carla.LaneChange.Both) and right_wpt and obstacle_vehicle_wpt.lane_id * right_wpt.lane_id &gt; 0 \
                and right_wpt.lane_type == carla.LaneType.Driving:
            rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                               target_wpt=right_wpt,
                                                                               overtake=True,
                                                                               world=self.vehicle.get_world())
            vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                         self._map.get_waypoint(self._ego_pos.location),
                                                         True)
            if not vehicle_state:
                print(&#34;right overtake is operated&#34;)
                self.overtake_counter = 100
                next_wpt = right_wpt.next(self._ego_speed / 3.6 * 6)[0]
                right_wpt = right_wpt.next(5)[0]
                self.set_destination(right_wpt.transform.location, next_wpt.transform.location,
                                     clean=True, end_reset=False)
                return vehicle_state

        return True

    def lane_change_management(self):
        &#34;&#34;&#34;
        Identify whether a potential hazard exits if operating lane change.
        Returns:
            bool: whether the lane change is dangerous
        &#34;&#34;&#34;
        ego_wpt = self._map.get_waypoint(self._ego_pos.location)
        ego_lane_id = ego_wpt.lane_id
        target_wpt = None

        # check the closest waypoint on the adjacent lane
        for wpt in self.get_local_planner()._waypoint_buffer:
            if wpt[0].lane_id != ego_lane_id:
                target_wpt = wpt[0]
                break
        if not target_wpt:
            return False

        rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                           target_wpt=target_wpt,
                                                                           overtake=False,
                                                                           world=self.vehicle.get_world())
        vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                     self._map.get_waypoint(self._ego_pos.location),
                                                     adjacent_check=True)
        return not vehicle_state

    def car_following_manager(self, vehicle, distance, target_speed=None):
        &#34;&#34;&#34;
        Module in charge of car-following behaviors when there&#39;s
        someone in front of us.

            :param target_speed:
            :param vehicle: car to follow
            :param distance: distance from vehicle
            :return control: carla.VehicleControl
        &#34;&#34;&#34;
        if not target_speed:
            target_speed = self.max_speed - self.speed_lim_dist

        vehicle_speed = get_speed(vehicle)

        delta_v = max(1, (self._ego_speed - vehicle_speed) / 3.6)
        ttc = distance / delta_v if delta_v != 0 else distance / np.nextafter(0., 1.)
        self.ttc = ttc
        # Under safety time distance, slow down.
        if self.safety_time &gt; ttc &gt; 0.0:
            target_speed = min(positive(vehicle_speed - self.speed_decrease),
                               target_speed)
            print(&#34;vehicle id %d: car following decreasing speed mode, target speed %f&#34;
                  % (self.vehicle.id, target_speed))

        # Actual safety distance area, try to follow the speed of the vehicle in front.
        else:
            target_speed = min(max(self.min_speed, vehicle_speed + 1),
                               target_speed)
            print(&#34;vehicle id %d: car following keep speed mode, target speed %f&#34;
                  % (self.vehicle.id, target_speed))
        return target_speed

    def run_step(self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True):
        &#34;&#34;&#34;
        Execute one step of navigation
        :param collision_detector_enabled: whether to enable collision detection.
        :param target_speed:  a manual order to achieve certain speed.
        :param lane_change_allowed: whether lane change is allowed. This is passed from platoon behavior agent.
        :return: control: carla.VehicleControl
        &#34;&#34;&#34;
        # retrieve ego location
        ego_vehicle_loc = self._ego_pos.location
        ego_vehicle_wp = self._map.get_waypoint(ego_vehicle_loc)
        # ttc reset to 1000 at the beginning
        self.ttc = 1000

        # simulation ends condition
        if abs(self._ego_pos.location.x - self.end_waypoint.transform.location.x) &lt;= 10 and \
                abs(self._ego_pos.location.y - self.end_waypoint.transform.location.y) &lt;= 10:
            print(&#39;Simulation is Over&#39;)
            sys.exit(0)

        # when overtake_counter &gt; 0, another overtake/lane change is forbidden
        if self.overtake_counter &gt; 0:
            self.overtake_counter -= 1

        # 1: Traffic light management
        if self.traffic_light_manager(ego_vehicle_wp) != 0:
            return 0, None

        # when the temporary route is finished, we return to the global route
        if len(self.get_local_planner().waypoints_queue) == 0 \
                and len(self.get_local_planner()._waypoint_buffer) &lt;= 2:
            print(&#39;Destination Reset!&#39;)
            self.overtake_allowed = True
            self.destination_push_flag = False
            self.set_destination(ego_vehicle_loc, self.end_waypoint.transform.location, clean=True, clean_history=True)

        # 2: Path generation based on the global route
        rx, ry, rk, ryaw = self._local_planner.generate_path()

        # check whether lane change is allowed
        if collision_detector_enabled and \
                self.get_local_planner().lane_id_change and \
                self.overtake_counter &lt;= 0 and \
                not self.destination_push_flag:
            self.lane_change_allowed = lane_change_allowed and self.lane_change_management()

        # 3: Collision check
        is_hazard = False
        if collision_detector_enabled:
            is_hazard, obstacle_vehicle, distance = self.collision_manager(rx, ry, ryaw, ego_vehicle_wp)
        car_following_flag = False

        if not is_hazard:
            self.hazard_flag = False

        # the case that the vehicle is doing lane change as planned but found vehicle blocking on the other lane
        if not self.lane_change_allowed and self.get_local_planner().lane_id_change \
                and not self.destination_push_flag and self.overtake_counter &lt;= 0:
            self.overtake_allowed = False
            reset_target = ego_vehicle_wp.next(self._ego_speed / 3.6 * 3)[0]
            print(&#39;destination pushed forward because of potential collision&#39;)

            self.destination_push_flag = True
            self.set_destination(ego_vehicle_loc, reset_target.transform.location, clean=True,
                                 end_reset=False)

            rx, ry, rk, ryaw = self._local_planner.generate_path()

        # the case that vehicle is blocking in front and overtake not allowed or it is doing overtaking
        # the second condition is to prevent successive overtaking
        elif is_hazard and (not self.overtake_allowed or self.overtake_counter &gt; 0
                            or self.get_local_planner().lane_change):
            car_following_flag = True

        elif is_hazard and self.overtake_allowed and self.overtake_counter &lt;= 0:
            obstacle_speed = get_speed(obstacle_vehicle)
            obstacle_lane_id = self._map.get_waypoint(obstacle_vehicle.get_location()).lane_id
            ego_lane_id = self._map.get_waypoint(self._ego_pos.location).lane_id

            # overtake the obstacle vehicle only when speed is bigger and the lane id is the same
            if ego_lane_id == obstacle_lane_id:
                # this flag is used for transition from cut-in joining to back joining
                self.hazard_flag = is_hazard
                # we only consider overtaking when speed is faster than the front obstacle
                if self._ego_speed &gt;= obstacle_speed - 5:
                    car_following_flag = self.overtake_management(obstacle_vehicle)
                else:
                    car_following_flag = True

        # 4. Car following behavior
        if car_following_flag:

            if distance &lt; self.break_distance:
                return 0, None

            target_speed = self.car_following_manager(obstacle_vehicle, distance, target_speed)
            target_speed, target_loc = self._local_planner.run_step(rx, ry, rk, target_speed=target_speed)
            return target_speed, target_loc

        # 5. Normal behavior
        target_speed, target_loc = self._local_planner.run_step(rx, ry, rk,
                                                                target_speed=self.max_speed - self.speed_lim_dist
                                                                if not target_speed else target_speed)

        return target_speed, target_loc</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent" href="../application/platooning/platoon_behavior_agent.html#opencda.core.application.platooning.platoon_behavior_agent.PlatooningBehaviorAgent">PlatooningBehaviorAgent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.add_white_list"><code class="name flex">
<span>def <span class="ident">add_white_list</span></span>(<span>self, vm)</span>
</code></dt>
<dd>
<div class="desc"><p>Add vehicle manager to</p>
<h2 id="args">Args</h2>
<p>vm ():
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_white_list(self, vm):
    &#34;&#34;&#34;
    Add vehicle manager to
    Args:
        vm ():

    Returns:

    &#34;&#34;&#34;
    self.white_list.append(vm)</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.car_following_manager"><code class="name flex">
<span>def <span class="ident">car_following_manager</span></span>(<span>self, vehicle, distance, target_speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Module in charge of car-following behaviors when there's
someone in front of us.</p>
<pre><code>:param target_speed:
:param vehicle: car to follow
:param distance: distance from vehicle
:return control: carla.VehicleControl
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def car_following_manager(self, vehicle, distance, target_speed=None):
    &#34;&#34;&#34;
    Module in charge of car-following behaviors when there&#39;s
    someone in front of us.

        :param target_speed:
        :param vehicle: car to follow
        :param distance: distance from vehicle
        :return control: carla.VehicleControl
    &#34;&#34;&#34;
    if not target_speed:
        target_speed = self.max_speed - self.speed_lim_dist

    vehicle_speed = get_speed(vehicle)

    delta_v = max(1, (self._ego_speed - vehicle_speed) / 3.6)
    ttc = distance / delta_v if delta_v != 0 else distance / np.nextafter(0., 1.)
    self.ttc = ttc
    # Under safety time distance, slow down.
    if self.safety_time &gt; ttc &gt; 0.0:
        target_speed = min(positive(vehicle_speed - self.speed_decrease),
                           target_speed)
        print(&#34;vehicle id %d: car following decreasing speed mode, target speed %f&#34;
              % (self.vehicle.id, target_speed))

    # Actual safety distance area, try to follow the speed of the vehicle in front.
    else:
        target_speed = min(max(self.min_speed, vehicle_speed + 1),
                           target_speed)
        print(&#34;vehicle id %d: car following keep speed mode, target speed %f&#34;
              % (self.vehicle.id, target_speed))
    return target_speed</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.collision_manager"><code class="name flex">
<span>def <span class="ident">collision_manager</span></span>(<span>self, rx, ry, ryaw, waypoint, adjacent_check=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This module is in charge of warning in case of a collision
:param adjacent_check: whether it is a check for adjacent lane
:param rx: x coordinates of plan path
:param ry: y coordinates of plan path
:param ryaw: yaw angle
:param waypoint: current waypoint of the agent
:return vehicle_state: True if there is a vehicle nearby, False if not
:return vehicle: nearby vehicle
:return distance: distance to nearby vehicle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collision_manager(self, rx, ry, ryaw, waypoint, adjacent_check=False):
    &#34;&#34;&#34;
    This module is in charge of warning in case of a collision
    :param adjacent_check: whether it is a check for adjacent lane
    :param rx: x coordinates of plan path
    :param ry: y coordinates of plan path
    :param ryaw: yaw angle
    :param waypoint: current waypoint of the agent
    :return vehicle_state: True if there is a vehicle nearby, False if not
    :return vehicle: nearby vehicle
    :return distance: distance to nearby vehicle
    &#34;&#34;&#34;

    def dist(v):
        return v.get_location().distance(waypoint.transform.location)

    vehicle_state = False
    min_distance = 100000
    target_vehicle = None

    for vehicle in self.obstacle_vehicles:
        collision_free = self._collision_check.collision_circle_check(rx, ry, ryaw, vehicle,
                                                                      self._ego_speed / 3.6,
                                                                      adjacent_check=adjacent_check)
        if not collision_free:
            vehicle_state = True
            distance = dist(vehicle)
            if distance &lt; min_distance:
                min_distance = distance
                target_vehicle = vehicle

    return vehicle_state, target_vehicle, min_distance</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.get_local_planner"><code class="name flex">
<span>def <span class="ident">get_local_planner</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the local planner</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_planner(self):
    &#34;&#34;&#34;return the local planner
    &#34;&#34;&#34;
    return self._local_planner</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.lane_change_management"><code class="name flex">
<span>def <span class="ident">lane_change_management</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Identify whether a potential hazard exits if operating lane change.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether the lane change is dangerous</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lane_change_management(self):
    &#34;&#34;&#34;
    Identify whether a potential hazard exits if operating lane change.
    Returns:
        bool: whether the lane change is dangerous
    &#34;&#34;&#34;
    ego_wpt = self._map.get_waypoint(self._ego_pos.location)
    ego_lane_id = ego_wpt.lane_id
    target_wpt = None

    # check the closest waypoint on the adjacent lane
    for wpt in self.get_local_planner()._waypoint_buffer:
        if wpt[0].lane_id != ego_lane_id:
            target_wpt = wpt[0]
            break
    if not target_wpt:
        return False

    rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                       target_wpt=target_wpt,
                                                                       overtake=False,
                                                                       world=self.vehicle.get_world())
    vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                 self._map.get_waypoint(self._ego_pos.location),
                                                 adjacent_check=True)
    return not vehicle_state</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.overtake_management"><code class="name flex">
<span>def <span class="ident">overtake_management</span></span>(<span>self, obstacle_vehicle)</span>
</code></dt>
<dd>
<div class="desc"><p>Overtake behavior.
:param obstacle_vehicle: the vehicle
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overtake_management(self, obstacle_vehicle):
    &#34;&#34;&#34;
    Overtake behavior.
    :param obstacle_vehicle: the vehicle
    :return:
    &#34;&#34;&#34;
    # obstacle vehicle&#39;s location
    obstacle_vehicle_loc = obstacle_vehicle.get_location()
    obstacle_vehicle_wpt = self._map.get_waypoint(obstacle_vehicle_loc)

    # whether a lane change is allowed
    left_turn = obstacle_vehicle_wpt.left_lane_marking.lane_change
    right_turn = obstacle_vehicle_wpt.right_lane_marking.lane_change

    # left and right waypoint of the obstacle vehicle
    left_wpt = obstacle_vehicle_wpt.get_left_lane()
    right_wpt = obstacle_vehicle_wpt.get_right_lane()

    # if the vehicle is able to operate left overtake
    if (left_turn == carla.LaneChange.Left or left_turn ==
        carla.LaneChange.Both) and left_wpt and obstacle_vehicle_wpt.lane_id * left_wpt.lane_id &gt; 0 \
            and left_wpt.lane_type == carla.LaneType.Driving:
        # this not the real plan path, but just a quick path to check collision
        rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                           target_wpt=left_wpt,
                                                                           overtake=True,
                                                                           world=self.vehicle.get_world())
        vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                     self._map.get_waypoint(self._ego_pos.location),
                                                     True)
        if not vehicle_state:
            print(&#34;left overtake is operated&#34;)
            self.overtake_counter = 100
            next_wpt = left_wpt.next(self._ego_speed / 3.6 * 6)[0]
            left_wpt = left_wpt.next(5)[0]
            self.set_destination(left_wpt.transform.location, next_wpt.transform.location,
                                 clean=True, end_reset=False)
            return vehicle_state

    if (right_turn == carla.LaneChange.Right or right_turn ==
        carla.LaneChange.Both) and right_wpt and obstacle_vehicle_wpt.lane_id * right_wpt.lane_id &gt; 0 \
            and right_wpt.lane_type == carla.LaneType.Driving:
        rx, ry, ryaw = self._collision_check.adjacent_lane_collision_check(ego_loc=self._ego_pos.location,
                                                                           target_wpt=right_wpt,
                                                                           overtake=True,
                                                                           world=self.vehicle.get_world())
        vehicle_state, _, _ = self.collision_manager(rx, ry, ryaw,
                                                     self._map.get_waypoint(self._ego_pos.location),
                                                     True)
        if not vehicle_state:
            print(&#34;right overtake is operated&#34;)
            self.overtake_counter = 100
            next_wpt = right_wpt.next(self._ego_speed / 3.6 * 6)[0]
            right_wpt = right_wpt.next(5)[0]
            self.set_destination(right_wpt.transform.location, next_wpt.transform.location,
                                 clean=True, end_reset=False)
            return vehicle_state

    return True</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.reroute"><code class="name flex">
<span>def <span class="ident">reroute</span></span>(<span>self, spawn_points)</span>
</code></dt>
<dd>
<div class="desc"><p>This method implements re-routing for vehicles approaching its destination.
It finds a new target and computes another path to reach it.</p>
<pre><code>:param spawn_points: list of possible destinations for the agent
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reroute(self, spawn_points):
    &#34;&#34;&#34;
    This method implements re-routing for vehicles approaching its destination.
    It finds a new target and computes another path to reach it.

        :param spawn_points: list of possible destinations for the agent
    &#34;&#34;&#34;

    print(&#34;Target almost reached, setting new destination...&#34;)
    random.shuffle(spawn_points)
    new_start = self._local_planner.waypoints_queue[-1][0].transform.location
    destination = spawn_points[0].location if spawn_points[0].location != new_start else spawn_points[1].location
    print(&#34;New destination: &#34; + str(destination))

    self.set_destination(new_start, destination)</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.run_step"><code class="name flex">
<span>def <span class="ident">run_step</span></span>(<span>self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute one step of navigation
:param collision_detector_enabled: whether to enable collision detection.
:param target_speed:
a manual order to achieve certain speed.
:param lane_change_allowed: whether lane change is allowed. This is passed from platoon behavior agent.
:return: control: carla.VehicleControl</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step(self, target_speed=None, collision_detector_enabled=True, lane_change_allowed=True):
    &#34;&#34;&#34;
    Execute one step of navigation
    :param collision_detector_enabled: whether to enable collision detection.
    :param target_speed:  a manual order to achieve certain speed.
    :param lane_change_allowed: whether lane change is allowed. This is passed from platoon behavior agent.
    :return: control: carla.VehicleControl
    &#34;&#34;&#34;
    # retrieve ego location
    ego_vehicle_loc = self._ego_pos.location
    ego_vehicle_wp = self._map.get_waypoint(ego_vehicle_loc)
    # ttc reset to 1000 at the beginning
    self.ttc = 1000

    # simulation ends condition
    if abs(self._ego_pos.location.x - self.end_waypoint.transform.location.x) &lt;= 10 and \
            abs(self._ego_pos.location.y - self.end_waypoint.transform.location.y) &lt;= 10:
        print(&#39;Simulation is Over&#39;)
        sys.exit(0)

    # when overtake_counter &gt; 0, another overtake/lane change is forbidden
    if self.overtake_counter &gt; 0:
        self.overtake_counter -= 1

    # 1: Traffic light management
    if self.traffic_light_manager(ego_vehicle_wp) != 0:
        return 0, None

    # when the temporary route is finished, we return to the global route
    if len(self.get_local_planner().waypoints_queue) == 0 \
            and len(self.get_local_planner()._waypoint_buffer) &lt;= 2:
        print(&#39;Destination Reset!&#39;)
        self.overtake_allowed = True
        self.destination_push_flag = False
        self.set_destination(ego_vehicle_loc, self.end_waypoint.transform.location, clean=True, clean_history=True)

    # 2: Path generation based on the global route
    rx, ry, rk, ryaw = self._local_planner.generate_path()

    # check whether lane change is allowed
    if collision_detector_enabled and \
            self.get_local_planner().lane_id_change and \
            self.overtake_counter &lt;= 0 and \
            not self.destination_push_flag:
        self.lane_change_allowed = lane_change_allowed and self.lane_change_management()

    # 3: Collision check
    is_hazard = False
    if collision_detector_enabled:
        is_hazard, obstacle_vehicle, distance = self.collision_manager(rx, ry, ryaw, ego_vehicle_wp)
    car_following_flag = False

    if not is_hazard:
        self.hazard_flag = False

    # the case that the vehicle is doing lane change as planned but found vehicle blocking on the other lane
    if not self.lane_change_allowed and self.get_local_planner().lane_id_change \
            and not self.destination_push_flag and self.overtake_counter &lt;= 0:
        self.overtake_allowed = False
        reset_target = ego_vehicle_wp.next(self._ego_speed / 3.6 * 3)[0]
        print(&#39;destination pushed forward because of potential collision&#39;)

        self.destination_push_flag = True
        self.set_destination(ego_vehicle_loc, reset_target.transform.location, clean=True,
                             end_reset=False)

        rx, ry, rk, ryaw = self._local_planner.generate_path()

    # the case that vehicle is blocking in front and overtake not allowed or it is doing overtaking
    # the second condition is to prevent successive overtaking
    elif is_hazard and (not self.overtake_allowed or self.overtake_counter &gt; 0
                        or self.get_local_planner().lane_change):
        car_following_flag = True

    elif is_hazard and self.overtake_allowed and self.overtake_counter &lt;= 0:
        obstacle_speed = get_speed(obstacle_vehicle)
        obstacle_lane_id = self._map.get_waypoint(obstacle_vehicle.get_location()).lane_id
        ego_lane_id = self._map.get_waypoint(self._ego_pos.location).lane_id

        # overtake the obstacle vehicle only when speed is bigger and the lane id is the same
        if ego_lane_id == obstacle_lane_id:
            # this flag is used for transition from cut-in joining to back joining
            self.hazard_flag = is_hazard
            # we only consider overtaking when speed is faster than the front obstacle
            if self._ego_speed &gt;= obstacle_speed - 5:
                car_following_flag = self.overtake_management(obstacle_vehicle)
            else:
                car_following_flag = True

    # 4. Car following behavior
    if car_following_flag:

        if distance &lt; self.break_distance:
            return 0, None

        target_speed = self.car_following_manager(obstacle_vehicle, distance, target_speed)
        target_speed, target_loc = self._local_planner.run_step(rx, ry, rk, target_speed=target_speed)
        return target_speed, target_loc

    # 5. Normal behavior
    target_speed, target_loc = self._local_planner.run_step(rx, ry, rk,
                                                            target_speed=self.max_speed - self.speed_lim_dist
                                                            if not target_speed else target_speed)

    return target_speed, target_loc</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.set_destination"><code class="name flex">
<span>def <span class="ident">set_destination</span></span>(<span>self, start_location, end_location, clean=False, end_reset=True, clean_history=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates a list of waypoints from agent's position to destination location
based on the route returned by the global router.</p>
<pre><code>:param end_reset: indicates whether the new destination is a temporary destination
:param start_location: initial position
:param end_location: final position
:param clean: boolean to clean the waypoint queue
:param clean_history:
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_destination(self, start_location, end_location, clean=False, end_reset=True, clean_history=False):
    &#34;&#34;&#34;
    This method creates a list of waypoints from agent&#39;s position to destination location
    based on the route returned by the global router.

        :param end_reset: indicates whether the new destination is a temporary destination
        :param start_location: initial position
        :param end_location: final position
        :param clean: boolean to clean the waypoint queue
        :param clean_history:
    &#34;&#34;&#34;
    if clean:
        self.get_local_planner().waypoints_queue.clear()
        self.get_local_planner().get_trajetory().clear()
        self.get_local_planner()._waypoint_buffer.clear()
    if clean_history:
        self.get_local_planner()._history_buffer.clear()

    self.start_waypoint = self._map.get_waypoint(start_location)

    # make sure the start waypoint is behind the vehicle
    if self._ego_pos:
        cur_loc = self._ego_pos.location
        cur_yaw = self._ego_pos.rotation.yaw
        _, angle = cal_distance_angle(self.start_waypoint.transform.location, cur_loc, cur_yaw)

        while angle &gt; 90:
            self.start_waypoint = self.start_waypoint.next(1)[0]
            _, angle = cal_distance_angle(self.start_waypoint.transform.location, cur_loc, cur_yaw)

    end_waypoint = self._map.get_waypoint(end_location)
    if end_reset:
        self.end_waypoint = end_waypoint

    route_trace = self._trace_route(self.start_waypoint, end_waypoint)

    self._local_planner.set_global_plan(route_trace, clean)</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.traffic_light_manager"><code class="name flex">
<span>def <span class="ident">traffic_light_manager</span></span>(<span>self, waypoint)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is in charge of behaviors for red lights and stops.</p>
<p>WARNING: What follows is a proxy to avoid having a car brake after running a yellow light.
This happens because the car is still under the influence of the semaphore,
even after passing it. So, the semaphore id is temporarely saved to
ignore it and go around this issue, until the car is near a new one.</p>
<pre><code>:param waypoint: current waypoint of the agent
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traffic_light_manager(self, waypoint):
    &#34;&#34;&#34;
    This method is in charge of behaviors for red lights and stops.

    WARNING: What follows is a proxy to avoid having a car brake after running a yellow light.
    This happens because the car is still under the influence of the semaphore,
    even after passing it. So, the semaphore id is temporarely saved to
    ignore it and go around this issue, until the car is near a new one.

        :param waypoint: current waypoint of the agent
    &#34;&#34;&#34;

    light_id = self.vehicle.get_traffic_light().id if self.vehicle.get_traffic_light() is not None else -1

    if self.light_state == &#34;Red&#34;:
        if not waypoint.is_junction and (self.light_id_to_ignore != light_id or light_id == -1):
            return 1
        elif waypoint.is_junction and light_id != -1:
            self.light_id_to_ignore = light_id
    if self.light_id_to_ignore != light_id:
        self.light_id_to_ignore = -1
    return 0</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.update_information"><code class="name flex">
<span>def <span class="ident">update_information</span></span>(<span>self, ego_pos, ego_speed, objects)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the perception and localization information to the behavior agent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ego_pos</code></strong> :&ensp;<code>carla.Transform</code></dt>
<dd>ego position from localization module.</dd>
<dt><strong><code>ego_speed</code></strong> :&ensp;<code>float</code></dt>
<dd>km/h, ego speed.</dd>
<dt><strong><code>objects</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Objects detection results from perception module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_information(self, ego_pos, ego_speed, objects):
    &#34;&#34;&#34;
    Update the perception and localization information to the behavior agent.
    Args:
        ego_pos (carla.Transform): ego position from localization module.
        ego_speed (float): km/h, ego speed.
        objects (dictionary): Objects detection results from perception module.
    &#34;&#34;&#34;
    # update localization information
    self._ego_speed = ego_speed
    self._ego_pos = ego_pos
    self.break_distance = self._ego_speed / 3.6 * self.emergency_param
    # update the localization info to trajectory planner
    self.get_local_planner().update_information(ego_pos, ego_speed)

    # current version only consider about vehicles
    obstacle_vehicles = objects[&#39;vehicles&#39;]
    self.obstacle_vehicles = self.white_list_match(obstacle_vehicles)

    # update the debug helper
    self.debug_helper.update(ego_speed, self.ttc)

    if self.ignore_traffic_light:
        self.light_state = &#34;Green&#34;
    else:
        # This method also includes stop signs and intersections.
        self.light_state = str(self.vehicle.get_traffic_light_state())</code></pre>
</details>
</dd>
<dt id="opencda.core.plan.behavior_agent.BehaviorAgent.white_list_match"><code class="name flex">
<span>def <span class="ident">white_list_match</span></span>(<span>self, obstacles)</span>
</code></dt>
<dd>
<div class="desc"><p>Match the detected obstacles with the white list. Remove the obstacles that are in white list.
The white list contains all position of target platoon member for joining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obstacles</code></strong> :&ensp;<code>list</code></dt>
<dd>a list of carla.Vehicle or ObstacleVehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(list): the new list of obstacles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def white_list_match(self, obstacles):
    &#34;&#34;&#34;
    Match the detected obstacles with the white list. Remove the obstacles that are in white list.
    The white list contains all position of target platoon member for joining.
    Args:
        obstacles (list):  a list of carla.Vehicle or ObstacleVehicle

    Returns:
        (list): the new list of obstacles.
    &#34;&#34;&#34;
    new_obstacle_list = []

    for o in obstacles:
        flag = False
        o_x = o.get_location().x
        o_y = o.get_location().y

        o_waypoint = self._map.get_waypoint(o.get_location())
        o_lane_id = o_waypoint.lane_id

        for vm in self.white_list:
            pos = vm.localizer.get_ego_pos()
            vm_x = pos.location.x
            vm_y = pos.location.y

            w_waypoint = self._map.get_waypoint(pos.location)
            w_lane_id = w_waypoint.lane_id

            # if the id is different, then not matched for sure
            if o_lane_id != w_lane_id:
                continue

            if abs(vm_x - o_x) &lt;= 3.0 and abs(vm_y - o_y) &lt;= 3.0:
                flag = True
                break
        if not flag:
            new_obstacle_list.append(o)

    return new_obstacle_list</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opencda.core.plan" href="index.html">opencda.core.plan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent" href="#opencda.core.plan.behavior_agent.BehaviorAgent">BehaviorAgent</a></code></h4>
<ul class="">
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.add_white_list" href="#opencda.core.plan.behavior_agent.BehaviorAgent.add_white_list">add_white_list</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.car_following_manager" href="#opencda.core.plan.behavior_agent.BehaviorAgent.car_following_manager">car_following_manager</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.collision_manager" href="#opencda.core.plan.behavior_agent.BehaviorAgent.collision_manager">collision_manager</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.get_local_planner" href="#opencda.core.plan.behavior_agent.BehaviorAgent.get_local_planner">get_local_planner</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.lane_change_management" href="#opencda.core.plan.behavior_agent.BehaviorAgent.lane_change_management">lane_change_management</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.overtake_management" href="#opencda.core.plan.behavior_agent.BehaviorAgent.overtake_management">overtake_management</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.reroute" href="#opencda.core.plan.behavior_agent.BehaviorAgent.reroute">reroute</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.run_step" href="#opencda.core.plan.behavior_agent.BehaviorAgent.run_step">run_step</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.set_destination" href="#opencda.core.plan.behavior_agent.BehaviorAgent.set_destination">set_destination</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.traffic_light_manager" href="#opencda.core.plan.behavior_agent.BehaviorAgent.traffic_light_manager">traffic_light_manager</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.update_information" href="#opencda.core.plan.behavior_agent.BehaviorAgent.update_information">update_information</a></code></li>
<li><code><a title="opencda.core.plan.behavior_agent.BehaviorAgent.white_list_match" href="#opencda.core.plan.behavior_agent.BehaviorAgent.white_list_match">white_list_match</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>